#include <stdio.h>
#include <Windows.h>

typedef struct DOS_HEADER {             // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} __IMAGE_DOS_HEADER;

typedef struct DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} __IMAGE_DATA_DIRECTORY;

typedef struct FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} __IMAGE_FILE_HEADER;

typedef struct OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER64;

typedef struct OPTIONAL_HEADER32 {
    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;
    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER32;

typedef struct NT_HEADER64 {
    DWORD Signature;
    FILE_HEADER FileHeader;
    OPTIONAL_HEADER64 OptionalHeader;
} __IMAGE_NT_HEADERS64;

typedef struct NT_HEADER32 {
    DWORD Signature;
    FILE_HEADER FileHeader;
    OPTIONAL_HEADER32 OptionalHeader;
} __IMAGE_NT_HEADERS32;

typedef struct SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} __IMAGE_SECTION_HEADER;


int print_headers(const char* filePath) {
    FILE* file = fopen(filePath, "rb");
    if (!file) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dosHeader;
    if (fread(&dosHeader, sizeof(DOS_HEADER), 1, file) != 1) {
        fclose(file);
        printf("Error reading DOS header\n");
        return 1;
    }

    printf("DOS Header:\n");
    printf("e_magic: %04X\n", dosHeader.e_magic);
    printf("e_cblp: %hu\n", dosHeader.e_cblp);
    printf("e_cp: %hu\n", dosHeader.e_cp);
    printf("e_crlc: %hu\n", dosHeader.e_crlc);
    printf("e_cparhdr: %hu\n", dosHeader.e_cparhdr);
    printf("e_minalloc: %hu\n", dosHeader.e_minalloc);
    printf("e_maxalloc: %hu\n", dosHeader.e_maxalloc);
    printf("e_ss: %hu\n", dosHeader.e_ss);
    printf("e_sp: %hu\n", dosHeader.e_sp);
    printf("e_csum: %hu\n", dosHeader.e_csum);
    printf("e_ip: %hu\n", dosHeader.e_ip);
    printf("e_cs: %hu\n", dosHeader.e_cs);
    printf("e_lfarlc: %hu\n", dosHeader.e_lfarlc);
    printf("e_ovno: %hu\n", dosHeader.e_ovno);
    printf("e_res: %hu %hu %hu %hu\n", dosHeader.e_res[0],dosHeader.e_res[1],dosHeader.e_res[2],dosHeader.e_res[3]);
    printf("e_oemid: %hu\n", dosHeader.e_oemid);
    printf("e_oeminfo: %hu\n", dosHeader.e_oeminfo);
    printf("e_res2: %hu %hu %hu %hu %hu %hu %hu %hu %hu %hu\n", dosHeader.e_res2[0], dosHeader.e_res2[1], dosHeader.e_res2[2], dosHeader.e_res2[3], dosHeader.e_res2[4], dosHeader.e_res2[5], dosHeader.e_res2[6], dosHeader.e_res2[7], dosHeader.e_res2[8], dosHeader.e_res2[9]);
    printf("e_lfanew: %hu\n", dosHeader.e_lfanew);


    fseek(file, dosHeader.e_lfanew, SEEK_SET);
    NT_HEADER32 ntHeader;
    if (fread(&ntHeader, sizeof(NT_HEADER32), 1, file) != 1) {
        fclose(file);
        printf("Error reading the NT header.\n");
        return 1;
    }

    if (ntHeader.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
        FILE* file64 = fopen(filePath, "rb");
        if (!file64) {
            printf("Error opening file.\n");
            return 1;
        }

        DOS_HEADER dosHeader64;
        if (fread(&dosHeader64, sizeof(DOS_HEADER), 1, file64) != 1) {
            fclose(file64);
            printf("Error reading DOS header\n");
            return 1;
        }

        fseek(file64, dosHeader64.e_lfanew, SEEK_SET);
        NT_HEADER64 ntHeader64;
        if (fread(&ntHeader64, sizeof(NT_HEADER64), 1, file64) != 1) {
            fclose(file64);
            printf("Error reading the NT header.\n");
            return 1;
        }

        printf("\n\nNT Header:\n");
        printf("Signature: %08X\n", ntHeader64.Signature);
        printf("File Header:\n");
        printf("Machine: %hu\n", ntHeader64.FileHeader.Machine);
        printf("NumberOfSections: %hu\n", ntHeader64.FileHeader.NumberOfSections);
        printf("TimeDateStamp: %hu\n", ntHeader64.FileHeader.TimeDateStamp);
        printf("PointerToSymbolTable: %hu\n", ntHeader64.FileHeader.PointerToSymbolTable);
        printf("NumberOfSymbols: %hu\n", ntHeader64.FileHeader.NumberOfSymbols);
        printf("SizeOfOptionalHeader: %hu\n", ntHeader64.FileHeader.SizeOfOptionalHeader);
        printf("Characteristics: %hu\n", ntHeader64.FileHeader.Characteristics);
        printf("Optional Header:\n");
        printf("Magic: %hu\n", ntHeader64.OptionalHeader.Magic);
        printf("Major: %u\n", ntHeader64.OptionalHeader.MajorLinkerVersion);
        printf("MinorLinkerVersion: %u\n", ntHeader64.OptionalHeader.MinorLinkerVersion);
        printf("SizeOfCode: %lu\n", ntHeader64.OptionalHeader.SizeOfCode);
        printf("SizeOfInitializedData: %lu\n", ntHeader64.OptionalHeader.SizeOfInitializedData);
        printf("SizeOfUninitializedData: %lu\n", ntHeader64.OptionalHeader.SizeOfUninitializedData);
        printf("AddressOfEntryPoint: %lu\n", ntHeader64.OptionalHeader.AddressOfEntryPoint);
        printf("BaseOfCode: %lu\n", ntHeader64.OptionalHeader.BaseOfCode);
        printf("ImageBase: %llu\n", ntHeader64.OptionalHeader.ImageBase);
        printf("SectionAlignment: %lu\n", ntHeader64.OptionalHeader.SectionAlignment);
        printf("FileAlignment: %lu\n", ntHeader64.OptionalHeader.FileAlignment);
        printf("MajorOperatingSystemVersion: %hu\n", ntHeader64.OptionalHeader.MajorOperatingSystemVersion);
        printf("MinorOperatingSystemVersion: %hu\n", ntHeader64.OptionalHeader.MinorOperatingSystemVersion);
        printf("MajorImageVersion: %hu\n", ntHeader64.OptionalHeader.MajorImageVersion);
        printf("MinorImageVersion: %hu\n", ntHeader64.OptionalHeader.MinorImageVersion);
        printf("MajorSubsystemVersion: %hu\n", ntHeader64.OptionalHeader.MajorSubsystemVersion);
        printf("MinorSubsystemVersion: %hu\n", ntHeader64.OptionalHeader.MinorSubsystemVersion);
        printf("Win32VersionValue: %lu\n", ntHeader64.OptionalHeader.Win32VersionValue);
        printf("SizeOfImage: %lu\n", ntHeader64.OptionalHeader.SizeOfImage);
        printf("SizeOfHeaders: %lu\n", ntHeader64.OptionalHeader.SizeOfHeaders);
        printf("CheckSum: %lu\n", ntHeader64.OptionalHeader.CheckSum);
        printf("Subsystem: %hu\n", ntHeader64.OptionalHeader.Subsystem);
        printf("DllCharacteristics: %hu\n", ntHeader64.OptionalHeader.DllCharacteristics);
        printf("SizeOfStackReserve: %llu\n", ntHeader64.OptionalHeader.SizeOfStackReserve);
        printf("SizeOfStackCommit: %llu\n", ntHeader64.OptionalHeader.SizeOfStackCommit);
        printf("SizeOfHeapReserve: %llu\n", ntHeader64.OptionalHeader.SizeOfHeapReserve);
        printf("SizeOfHeapCommit: %llu\n", ntHeader64.OptionalHeader.SizeOfHeapCommit);
        printf("LoaderFlags: %lu\n", ntHeader64.OptionalHeader.LoaderFlags);
        printf("NumberOfRvaAndSizes: %lu\n", ntHeader64.OptionalHeader.NumberOfRvaAndSizes);
        printf("Data Directory:\n");
        for (int i = 0; i < (sizeof(ntHeader64.OptionalHeader.DataDirectory) / sizeof(ntHeader64.OptionalHeader.DataDirectory[0])); i++) {
            printf("Entry %d - Virtual Address: %lu Size: %lu\n", i, ntHeader64.OptionalHeader.DataDirectory[i].VirtualAddress, ntHeader64.OptionalHeader.DataDirectory[i].Size);
        }

        printf("\n\nSection Headers:\n");
        SECTION_HEADER sectionHeader;
        for (int i = 0; i < ntHeader64.FileHeader.NumberOfSections; i++) {
            if (fread(&sectionHeader, sizeof(SECTION_HEADER), 1, file) != 1) {
                fclose(file);
                return 1;
            }
            printf("\tSection Name: %s\n", sectionHeader.Name);
            printf("\tPhysicalAddress: %u\n", sectionHeader.Misc.PhysicalAddress);
            printf("\tVirtualSize: %u\n", sectionHeader.Misc.VirtualSize);
            printf("\tVirtual Address: %u\n", sectionHeader.VirtualAddress);
            printf("\tSize of Raw Data: %u\n", sectionHeader.SizeOfRawData);
            printf("\tPointerToRawData: %u\n", sectionHeader.PointerToRawData);
            printf("\tPointerToRelocations: %u\n", sectionHeader.PointerToRelocations);
            printf("\tPointerToLinenumbers: %u\n", sectionHeader.PointerToLinenumbers);
            printf("\tNumberOfRelocations: %hu\n", sectionHeader.NumberOfRelocations);
            printf("\tNumberOfLinenumbers: %hu\n", sectionHeader.NumberOfLinenumbers);
            printf("\tCharacteristics: %u\n\n", sectionHeader.Characteristics);
        }

        printf("The executable is 64 bit");
        fclose(file64);
    }
    else if (ntHeader.FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
        printf("\n\nNT Header:\n");
        printf("Signature: %08X\n", ntHeader.Signature);
        printf("File Header:\n");
        printf("Machine: %hu\n", ntHeader.FileHeader.Machine);
        printf("NumberOfSections: %hu\n", ntHeader.FileHeader.NumberOfSections);
        printf("TimeDateStamp: %hu\n", ntHeader.FileHeader.TimeDateStamp);
        printf("PointerToSymbolTable: %hu\n", ntHeader.FileHeader.PointerToSymbolTable);
        printf("NumberOfSymbols: %hu\n", ntHeader.FileHeader.NumberOfSymbols);
        printf("SizeOfOptionalHeader: %hu\n", ntHeader.FileHeader.SizeOfOptionalHeader);
        printf("Characteristics: %hu\n", ntHeader.FileHeader.Characteristics);
        printf("Optional Header:\n");
        printf("Magic: %hu\n", ntHeader.OptionalHeader.Magic);
        printf("Major: %u\n", ntHeader.OptionalHeader.MajorLinkerVersion);
        printf("MinorLinkerVersion: %u\n", ntHeader.OptionalHeader.MinorLinkerVersion);
        printf("SizeOfCode: %lu\n", ntHeader.OptionalHeader.SizeOfCode);
        printf("SizeOfInitializedData: %lu\n", ntHeader.OptionalHeader.SizeOfInitializedData);
        printf("SizeOfUninitializedData: %lu\n", ntHeader.OptionalHeader.SizeOfUninitializedData);
        printf("AddressOfEntryPoint: %lu\n", ntHeader.OptionalHeader.AddressOfEntryPoint);
        printf("BaseOfCode: %lu\n", ntHeader.OptionalHeader.BaseOfCode);
        printf("BaseOfData: %lu\n", ntHeader.OptionalHeader.BaseOfData);
        printf("ImageBase: %lu\n", ntHeader.OptionalHeader.ImageBase);
        printf("SectionAlignment: %lu\n", ntHeader.OptionalHeader.SectionAlignment);
        printf("FileAlignment: %lu\n", ntHeader.OptionalHeader.FileAlignment);
        printf("MajorOperatingSystemVersion: %hu\n", ntHeader.OptionalHeader.MajorOperatingSystemVersion);
        printf("MinorOperatingSystemVersion: %hu\n", ntHeader.OptionalHeader.MinorOperatingSystemVersion);
        printf("MajorImageVersion: %hu\n", ntHeader.OptionalHeader.MajorImageVersion);
        printf("MinorImageVersion: %hu\n", ntHeader.OptionalHeader.MinorImageVersion);
        printf("MajorSubsystemVersion: %hu\n", ntHeader.OptionalHeader.MajorSubsystemVersion);
        printf("MinorSubsystemVersion: %hu\n", ntHeader.OptionalHeader.MinorSubsystemVersion);
        printf("Win32VersionValue: %lu\n", ntHeader.OptionalHeader.Win32VersionValue);
        printf("SizeOfImage: %lu\n", ntHeader.OptionalHeader.SizeOfImage);
        printf("SizeOfHeaders: %lu\n", ntHeader.OptionalHeader.SizeOfHeaders);
        printf("CheckSum: %lu\n", ntHeader.OptionalHeader.CheckSum);
        printf("Subsystem: %hu\n", ntHeader.OptionalHeader.Subsystem);
        printf("DllCharacteristics: %hu\n", ntHeader.OptionalHeader.DllCharacteristics);
        printf("SizeOfStackReserve: %lu\n", ntHeader.OptionalHeader.SizeOfStackReserve);
        printf("SizeOfStackCommit: %lu\n", ntHeader.OptionalHeader.SizeOfStackCommit);
        printf("SizeOfHeapReserve: %lu\n", ntHeader.OptionalHeader.SizeOfHeapReserve);
        printf("SizeOfHeapCommit: %lu\n", ntHeader.OptionalHeader.SizeOfHeapCommit);
        printf("LoaderFlags: %lu\n", ntHeader.OptionalHeader.LoaderFlags);
        printf("NumberOfRvaAndSizes: %lu\n", ntHeader.OptionalHeader.NumberOfRvaAndSizes);
        printf("Data Directory:\n");
        for (int i = 0; i < (sizeof(ntHeader.OptionalHeader.DataDirectory) / sizeof(ntHeader.OptionalHeader.DataDirectory[0])); i++) {
            printf("Entry %d - Virtual Address: %lu Size: %lu\n", i, ntHeader.OptionalHeader.DataDirectory[i].VirtualAddress, ntHeader.OptionalHeader.DataDirectory[i].Size);
        }

        printf("\n\nSection Headers:\n");
        SECTION_HEADER sectionHeader;
        for (int i = 0; i < ntHeader.FileHeader.NumberOfSections; i++) {
            if (fread(&sectionHeader, sizeof(SECTION_HEADER), 1, file) != 1) {
                fclose(file);
                return 1;
            }
            printf("\tSection Name: %s\n", sectionHeader.Name);
            printf("\tPhysicalAddress: %u\n", sectionHeader.Misc.PhysicalAddress);
            printf("\tVirtualSize: %u\n", sectionHeader.Misc.VirtualSize);
            printf("\tVirtual Address: %u\n", sectionHeader.VirtualAddress);
            printf("\tSize of Raw Data: %u\n", sectionHeader.SizeOfRawData);
            printf("\tPointerToRawData: %u\n", sectionHeader.PointerToRawData);
            printf("\tPointerToRelocations: %u\n", sectionHeader.PointerToRelocations);
            printf("\tPointerToLinenumbers: %u\n", sectionHeader.PointerToLinenumbers);
            printf("\tNumberOfRelocations: %hu\n", sectionHeader.NumberOfRelocations);
            printf("\tNumberOfLinenumbers: %hu\n", sectionHeader.NumberOfLinenumbers);
            printf("\tCharacteristics: %u\n\n", sectionHeader.Characteristics);
        }

        printf("The executable is 32 bit");
        fclose(file);
    }
    else {
        printf("Error executbale not 64 or 32 bit");
    }
    
    return 0;
}

int main(int argc, char* argv[]) {

    if (argc != 2) {
        printf("Incorrect arugments - please provide a file path to an executable\n");
        return 1;
    }

    const char* filePath = argv[1];

    return print_headers(filePath);

    while (true) {
        // do nothing
    }

    return 0;
}
