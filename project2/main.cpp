#include <stdio.h>
#include <Windows.h>
#include <vector>
using namespace std;

typedef struct DOS_HEADER {             // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} __IMAGE_DOS_HEADER;

typedef struct DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} __IMAGE_DATA_DIRECTORY;

typedef struct FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} __IMAGE_FILE_HEADER;

typedef struct OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER64;

typedef struct OPTIONAL_HEADER32 {
    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;
    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER32;

typedef struct NT_HEADER64 {
    DWORD Signature;
    FILE_HEADER FileHeader;
    OPTIONAL_HEADER64 OptionalHeader;
} __IMAGE_NT_HEADERS64;

typedef struct NT_HEADER32 {
    DWORD Signature;
    FILE_HEADER FileHeader;
    OPTIONAL_HEADER32 OptionalHeader;
} __IMAGE_NT_HEADERS32;

typedef struct SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} __IMAGE_SECTION_HEADER;

typedef struct IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;
        DWORD   OriginalFirstThunk;
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;
    DWORD   ForwarderChain;
    DWORD   Name;
    DWORD   FirstThunk;
} __IMAGE_IMPORT_DESCRIPTOR;

typedef struct IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} __IMAGE_IMPORT_BY_NAME;

typedef struct BASE_RELOCATION {
    DWORD VirtualAddress;
    DWORD SizeOfBlock;
} __IMAGE_BASE_RELOCATION;

typedef struct EXPORT_DIRECTORY {
    DWORD   Characteristics;                         
    DWORD   TimeDateStamp;                       
    WORD    MajorVersion;                            
    WORD    MinorVersion;                             
    DWORD   Name;                         
    DWORD   Base;
    DWORD   NumberOfFunctions;              
    DWORD   NumberOfNames;                
    DWORD   AddressOfFunctions;                
    DWORD   AddressOfNames;                     
    DWORD   AddressOfNameOrdinals;       
} __IMAGE_EXPORT_DIRECTORY;



#pragma warning(disable : 4996)
int print_32_bit(const char* filePath) {
    FILE* file32 = fopen(filePath, "rb");
    if (!file32) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dos_header32;
    if (fread(&dos_header32, sizeof(DOS_HEADER), 1, file32) != 1) {
        fclose(file32);
        printf("Error reading DOS header\n");
        return 1;
    }

    fseek(file32, dos_header32.e_lfanew, SEEK_SET);
    NT_HEADER32 nt_header32;
    if (fread(&nt_header32, sizeof(NT_HEADER32), 1, file32) != 1) {
        fclose(file32);
        printf("Error reading the NT header.\n");
        return 1;
    }

    SECTION_HEADER section_header;
    vector<SECTION_HEADER> section_headers;
    for (int i = 0; i < nt_header32.FileHeader.NumberOfSections; i++) {
        if (fread(&section_header, sizeof(SECTION_HEADER), 1, file32) != 1) {
            fclose(file32);
            return 1;
        }
        section_headers.push_back(section_header);
    }

    DWORD import_table_rva = nt_header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    DWORD import_table_va = 0;
    DWORD import_table_foa = 0;

    unsigned char name[8] = { '.', 'i', 'd', 'a', 't', 'a', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(name, s.Name, 8) == 0) {
            import_table_va = s.VirtualAddress;
            import_table_foa = s.PointerToRawData;
        }
    }

    if (import_table_va == 0) {
		printf("Import table not found\n");
	}
    else {
        DWORD import_directory_address = (import_table_rva - import_table_va) + import_table_foa;
        vector<IMPORT_DESCRIPTOR> import_descriptors;

        // Print all the entires in the import table and save them for later
        printf("-----Import Table-----\n");
        int count = 0;
        while (true) {
            IMPORT_DESCRIPTOR current_import;
            int offset = (count * sizeof(IMPORT_DESCRIPTOR)) + import_directory_address;
            fseek(file32, offset, SEEK_SET);
            fread(&current_import, sizeof(IMPORT_DESCRIPTOR), 1, file32);
            if (current_import.Name == 0x0000 && current_import.FirstThunk == 0x0000) {
                break;
            }
            printf("- Entry %d -\n", count + 1);
            printf("Characteristics: %#06x\n", current_import.Characteristics);
            printf("OriginalFirstThunk: %#06x\n", current_import.OriginalFirstThunk);
            printf("TimeDateStamp: %#06x\n", current_import.TimeDateStamp);
            printf("ForwarderChain: %#06x\n", current_import.ForwarderChain);
            printf("Name: %#06x\n", current_import.Name);
            printf("FirstThunk: %#06x\n\n", current_import.FirstThunk);

            count++;
            import_descriptors.push_back(current_import);
        }

        // print the all of the INT tables and the name table associated with each one
        DWORD INT_address = (import_descriptors[0].OriginalFirstThunk - import_table_va) + import_table_foa; // address of first INT table

        for (int i = 0; i < import_descriptors.size(); i++) {
            printf("-----INT Table %d-----\n", i + 1);
            int count = 0;
            vector<DWORD> INT_entries;
            while (true) {
                int offset = (count * sizeof(DWORD)) + INT_address;
                DWORD current_INT;
                fseek(file32, offset, SEEK_SET);
                fread(&current_INT, sizeof(DWORD), 1, file32);
                if (current_INT == 0x0000) {
                    break;
                }
                printf("Entry %d: %#06x\n", count + 1, current_INT);
                INT_entries.push_back(current_INT);
                count++;
            }
            printf("\n");

            // print the name table associated with the INT table
            printf("-----Name Table %d-----\n", i + 1);
            for (int j = 0; j < INT_entries.size(); j++) {
                DWORD INT = INT_entries[j];
                int MSB = INT >> 31;

                if (MSB == 0) {
                    // INT is a RVA to name/hint struct
                    // calculate address 
                    DWORD name_address = (INT - import_table_va) + import_table_foa;

                    IMPORT_BY_NAME current_name;
                    fseek(file32, name_address, SEEK_SET);
                    fread(&current_name, sizeof(IMPORT_BY_NAME), 1, file32);
                    printf("- Entry %d -\n", j + 1);
                    printf("Hint: %d\n", current_name.Hint);
                    printf("Name: ");
                    int c = 0;
                    while (true) {
                        int offset = (c * sizeof(CHAR)) + name_address + sizeof(WORD);
                        CHAR current_char;
                        fseek(file32, offset, SEEK_SET);
                        fread(&current_char, sizeof(CHAR), 1, file32);
                        if (current_char == 0x00) {
                            c -= 1;
                            break;
                        }
                        c++;
                        printf("%c", current_char);
                    }
                    printf("\n");
                }
            }
            printf("\n");
        }

        // print the all of the IAT tables
        DWORD IAT_address = (import_descriptors[0].FirstThunk - import_table_va) + import_table_foa; // address of first IAT table
        for (int i = 0; i < import_descriptors.size(); i++) {
            printf("-----IAT Table %d-----\n", i + 1);
            int count = 0;
            while (true) {
                int offset = (count * sizeof(DWORD)) + INT_address;
                DWORD current_IAT;
                fseek(file32, offset, SEEK_SET);
                fread(&current_IAT, sizeof(DWORD), 1, file32);
                if (current_IAT == 0x0000) {
                    break;
                }
                printf("Entry %d: %#06x\n", count + 1, current_IAT);
                count++;
            }
            printf("\n");
        }
    }

    DWORD reloc_table_rva = nt_header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    DWORD reloc_table_va = 0;
    DWORD reloc_table_foa = 0;

    unsigned char r_name[8] = { '.', 'r', 'e', 'l', 'o', 'c', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(r_name, s.Name, 8) == 0) {
            reloc_table_va = s.VirtualAddress;
            reloc_table_foa = s.PointerToRawData;
        }
    }

    if (reloc_table_va == 0) {
        printf("Relocation table not found\n");
    }
    else {
        DWORD reloc_directory_address = (reloc_table_rva - reloc_table_va) + reloc_table_foa;
        vector<BASE_RELOCATION> reloc_descriptors;

        // Print all the entires in the reloc table and save them for later
        printf("-----Relocation Table-----\n");
        int count = 0;
        int reloc_table_offset = 0;
        while (true) {
            BASE_RELOCATION current_reloc;
            int offset = reloc_table_offset + reloc_directory_address;
            fseek(file32, offset, SEEK_SET);
            fread(&current_reloc, sizeof(BASE_RELOCATION), 1, file32);
            if (current_reloc.VirtualAddress == 0x0000 && current_reloc.SizeOfBlock == 0x0000) {
                break;
            }
            printf("- Entry %d -\n", count + 1);
            printf("VirtualAddress: %#010x\n", current_reloc.VirtualAddress);
            printf("SizeOfBlock: %#010x\n\n", current_reloc.SizeOfBlock);

            // if needed add sizeof(BASE_RELOCATION) to offset and seek to that location then read the SizeOfBlock - sizeof(BASE_RELOCATION) to get the data

            count++;
            reloc_table_offset += current_reloc.SizeOfBlock;
            reloc_descriptors.push_back(current_reloc);
        }
    }


    DWORD export_table_rva = nt_header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    DWORD export_table_va = 0;
    DWORD export_table_foa = 0;

    unsigned char e_name[8] = { '.', 'e', 'd', 'a', 't', 'a', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(e_name, s.Name, 8) == 0) {
            export_table_va = s.VirtualAddress;
            export_table_foa = s.PointerToRawData;
        }
    }

    if (export_table_va == 0) {
        printf("Export table not found\n");
    }
    else {
        DWORD export_directory_address = (export_table_rva - export_table_va) + export_table_foa;

        printf("-----Export Table-----\n");
        EXPORT_DIRECTORY export_dir;
        fseek(file32, export_directory_address, SEEK_SET);
        fread(&export_dir, sizeof(BASE_RELOCATION), 1, file32);
        printf("Characteristics: %#010x\n", export_dir.Characteristics);
        printf("TimeDateStamp: %#010x\n", export_dir.TimeDateStamp);
        printf("MajorVersion: %#010x\n", export_dir.MajorVersion);
        printf("MinorVersion: %#010x\n", export_dir.MinorVersion);
        printf("Name: %#010x\n", export_dir.Name);
        printf("Base: %#010x\n", export_dir.Base);
        printf("NumberOfFunctions: %#010x\n", export_dir.NumberOfFunctions);
        printf("NumberOfNames: %#010x\n", export_dir.NumberOfNames);
        printf("AddressOfFunctions: %#010x\n", export_dir.AddressOfFunctions);
        printf("AddressOfNames: %#010x\n", export_dir.AddressOfNames);
        printf("AddressOfNameOrdinals: %#010x\n", export_dir.AddressOfNameOrdinals);
    }


    printf("The executable is 32 bit");
    fclose(file32);

    return 0;
}

#pragma warning(disable : 4996)
int print_64_bit(const char* filePath) {
    FILE* file64 = fopen(filePath, "rb");
    if (!file64) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dos_header64;
    if (fread(&dos_header64, sizeof(DOS_HEADER), 1, file64) != 1) {
        fclose(file64);
        printf("Error reading DOS header\n");
        return 1;
    }

    fseek(file64, dos_header64.e_lfanew, SEEK_SET);
    NT_HEADER64 nt_header64;
    if (fread(&nt_header64, sizeof(NT_HEADER64), 1, file64) != 1) {
        fclose(file64);
        printf("Error reading the NT header.\n");
        return 1;
    }

    SECTION_HEADER section_header;
    vector<SECTION_HEADER> section_headers;
    for (int i = 0; i < nt_header64.FileHeader.NumberOfSections; i++) {
        if (fread(&section_header, sizeof(SECTION_HEADER), 1, file64) != 1) {
            fclose(file64);
            return 1;
        }
        section_headers.push_back(section_header);
    }

    DWORD import_table_rva = nt_header64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    DWORD import_table_va = 0;
    DWORD import_table_foa = 0;

    unsigned char i_name[8] = { '.', 'i', 'd', 'a', 't', 'a', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(i_name, s.Name, 8) == 0) {
            import_table_va = s.VirtualAddress;
            import_table_foa = s.PointerToRawData;
        }
    }

    if (import_table_va == 0) {
        printf("Import table not found\n");
    }
    else {
        DWORD import_directory_address = (import_table_rva - import_table_va) + import_table_foa;
        vector<IMPORT_DESCRIPTOR> import_descriptors;

        // Print all the entires in the import table and save them for later
        printf("-----Import Table-----\n");
        int count = 0;
        while (true) {
            IMPORT_DESCRIPTOR current_import;
            int offset = (count * sizeof(IMPORT_DESCRIPTOR)) + import_directory_address;
            fseek(file64, offset, SEEK_SET);
            fread(&current_import, sizeof(IMPORT_DESCRIPTOR), 1, file64);
            if (current_import.Name == 0x00000000 && current_import.FirstThunk == 0x00000000) {
                break;
            }
            printf("- Entry %d -\n", count + 1);
            printf("Characteristics: %#010x\n", current_import.Characteristics);
            printf("OriginalFirstThunk: %#010x\n", current_import.OriginalFirstThunk);
            printf("TimeDateStamp: %#010x\n", current_import.TimeDateStamp);
            printf("ForwarderChain: %#010x\n", current_import.ForwarderChain);
            printf("Name: %#010x\n", current_import.Name);
            printf("FirstThunk: %#010x\n\n", current_import.FirstThunk);

            count++;
            import_descriptors.push_back(current_import);
        }

        // print the all of the INT tables and the name table associated with each one
        DWORD INT_address = (import_descriptors[0].OriginalFirstThunk - import_table_va) + import_table_foa; // address of first INT table

        for (int i = 0; i < import_descriptors.size(); i++) {
            printf("-----INT Table %d-----\n", i + 1);
            int count = 0;
            vector<ULONGLONG> INT_entries;
            while (true) {
                int offset = (count * sizeof(ULONGLONG)) + INT_address;
                ULONGLONG current_INT;
                fseek(file64, offset, SEEK_SET);
                fread(&current_INT, sizeof(ULONGLONG), 1, file64);
                if (current_INT == 0x00000000) {
                    break;
                }
                printf("Entry %d: %#010x\n", count + 1, current_INT);
                INT_entries.push_back(current_INT);
                count++;
            }
            printf("\n");

            // print the name table associated with the INT table
            printf("-----Name Table %d-----\n", i + 1);
            for (int j = 0; j < INT_entries.size(); j++) {
                // TODO get most significant bit of INT
                ULONGLONG INT = INT_entries[j];
                int MSB = INT >> 63;

                if (MSB == 0) {
                    // INT is a RVA to name/hint struct
                    // calculate address 
                    DWORD name_address = (INT - import_table_va) + import_table_foa;

                    IMPORT_BY_NAME current_name;
                    fseek(file64, name_address, SEEK_SET);
                    fread(&current_name, sizeof(IMPORT_BY_NAME), 1, file64);
                    printf("- Entry %d -\n", j + 1);
                    printf("Hint: %d\n", current_name.Hint);
                    printf("Name: ");
                    int c = 0;
                    while (true) {
                        int offset = (c * sizeof(CHAR)) + name_address + sizeof(WORD);
                        CHAR current_char;
                        fseek(file64, offset, SEEK_SET);
                        fread(&current_char, sizeof(CHAR), 1, file64);
                        if (current_char == 0x00) {
                            break;
                        }
                        c++;
                        printf("%c", current_char);
                    }
                    printf("\n");
                }
            }
            printf("\n");
        }

        // print the all of the IAT tables
        DWORD IAT_address = (import_descriptors[0].FirstThunk - import_table_va) + import_table_foa; // address of first IAT table
        for (int i = 0; i < import_descriptors.size(); i++) {
            printf("-----IAT Table %d-----\n", i + 1);
            int count = 0;
            while (true) {
                int offset = (count * sizeof(ULONGLONG)) + INT_address;
                ULONGLONG current_IAT;
                fseek(file64, offset, SEEK_SET);
                fread(&current_IAT, sizeof(ULONGLONG), 1, file64);
                if (current_IAT == 0x00000000) {
                    break;
                }
                printf("Entry %d: %#010x\n", count + 1, current_IAT);
                count++;
            }
            printf("\n");
        }
    }


    DWORD reloc_table_rva = nt_header64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    DWORD reloc_table_va = 0;
    DWORD reloc_table_foa = 0;

    unsigned char r_name[8] = { '.', 'r', 'e', 'l', 'o', 'c', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(r_name, s.Name, 8) == 0) {
            reloc_table_va = s.VirtualAddress;
            reloc_table_foa = s.PointerToRawData;
        }
    }

    if (reloc_table_va == 0) {
        printf("Relocation table not found\n");
    }
    else {
        DWORD reloc_directory_address = (reloc_table_rva - reloc_table_va) + reloc_table_foa;
        vector<BASE_RELOCATION> reloc_descriptors;

        // Print all the entires in the reloc table and save them for later
        printf("-----Relocation Table-----\n");
        int count = 0;
        int reloc_table_offset = 0;
        while (true) {
            BASE_RELOCATION current_reloc;
            int offset = reloc_table_offset + reloc_directory_address;
            fseek(file64, offset, SEEK_SET);
            fread(&current_reloc, sizeof(BASE_RELOCATION), 1, file64);
            if (current_reloc.VirtualAddress == 0x0000 && current_reloc.SizeOfBlock == 0x0000) {
                break;
            }
            printf("- Entry %d -\n", count + 1);
            printf("VirtualAddress: %#010x\n", current_reloc.VirtualAddress);
            printf("SizeOfBlock: %#010x\n\n", current_reloc.SizeOfBlock);

            // if needed add sizeof(BASE_RELOCATION) to offset and seek to that location then read the SizeOfBlock - sizeof(BASE_RELOCATION) to get the data
            
            count++;
            reloc_table_offset += current_reloc.SizeOfBlock;
            reloc_descriptors.push_back(current_reloc);
        }
    }


    DWORD export_table_rva = nt_header64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    DWORD export_table_va = 0;
    DWORD export_table_foa = 0;

    unsigned char e_name[8] = { '.', 'e', 'd', 'a', 't', 'a', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(e_name, s.Name, 8) == 0) {
            export_table_va = s.VirtualAddress;
            export_table_foa = s.PointerToRawData;
        }
    }

    if (export_table_va == 0) {
        printf("Export table not found\n");
    }
    else {
        DWORD export_directory_address = (export_table_rva - export_table_va) + export_table_foa;

        printf("-----Export Table-----\n");
        EXPORT_DIRECTORY export_dir;
        fseek(file64, export_directory_address, SEEK_SET);
        fread(&export_dir, sizeof(BASE_RELOCATION), 1, file64);
        printf("Characteristics: %#010x\n", export_dir.Characteristics);
        printf("TimeDateStamp: %#010x\n", export_dir.TimeDateStamp);
        printf("MajorVersion: %#010x\n", export_dir.MajorVersion);
        printf("MinorVersion: %#010x\n", export_dir.MinorVersion);
        printf("Name: %#010x\n", export_dir.Name);
        printf("Base: %#010x\n", export_dir.Base);
        printf("NumberOfFunctions: %#010x\n", export_dir.NumberOfFunctions);
        printf("NumberOfNames: %#010x\n", export_dir.NumberOfNames);
        printf("AddressOfFunctions: %#010x\n", export_dir.AddressOfFunctions);
        printf("AddressOfNames: %#010x\n", export_dir.AddressOfNames);
        printf("AddressOfNameOrdinals: %#010x\n", export_dir.AddressOfNameOrdinals);
    }

    printf("\n\nThe executable is 64 bit");
    fclose(file64);

    return 0;
}

#pragma warning(disable : 4996)
int print_tables(const char* filePath) {
    FILE* file = fopen(filePath, "rb");
    if (!file) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dosHeader;
    if (fread(&dosHeader, sizeof(DOS_HEADER), 1, file) != 1) {
        fclose(file);
        printf("Error reading DOS header\n");
        return 1;
    }

    fseek(file, dosHeader.e_lfanew, SEEK_SET);
    NT_HEADER32 ntHeader;
    if (fread(&ntHeader, sizeof(NT_HEADER32), 1, file) != 1) {
        fclose(file);
        printf("Error reading the NT header.\n");
        return 1;
    }

    if (ntHeader.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
        return print_64_bit(filePath);

    }
    else if (ntHeader.FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
        return print_32_bit(filePath);
    }
    else {
        printf("Error executable not 64 or 32 bit");
        return 1;
    }

    return 0;
}

int main(int argc, char* argv[]) {

    if (argc != 2) {
        printf("Incorrect arugments - please provide a file path to an executable\n");
        return 1;
    }

    const char* filePath = argv[1];

    return print_tables(filePath);
}
