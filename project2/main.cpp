#include <stdio.h>
#include <Windows.h>
#include <vector>
using namespace std;

typedef struct DOS_HEADER {             // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} __IMAGE_DOS_HEADER;

typedef struct DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} __IMAGE_DATA_DIRECTORY;

typedef struct FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} __IMAGE_FILE_HEADER;

typedef struct OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER64;

typedef struct OPTIONAL_HEADER32 {
    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;
    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER32;

typedef struct NT_HEADER64 {
    DWORD Signature;
    FILE_HEADER FileHeader;
    OPTIONAL_HEADER64 OptionalHeader;
} __IMAGE_NT_HEADERS64;

typedef struct NT_HEADER32 {
    DWORD Signature;
    FILE_HEADER FileHeader;
    OPTIONAL_HEADER32 OptionalHeader;
} __IMAGE_NT_HEADERS32;

typedef struct SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} __IMAGE_SECTION_HEADER;


typedef struct IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;
        DWORD   OriginalFirstThunk;
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;
    DWORD   ForwarderChain;
    DWORD   Name;
    DWORD   FirstThunk;
} __IMAGE_IMPORT_DESCRIPTOR;


typedef struct IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} __IMAGE_IMPORT_BY_NAME;



#pragma warning(disable : 4996)
int print_32_bit(const char* filePath) {
    FILE* file32 = fopen(filePath, "rb");
    if (!file32) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dos_header32;
    if (fread(&dos_header32, sizeof(DOS_HEADER), 1, file32) != 1) {
        fclose(file32);
        printf("Error reading DOS header\n");
        return 1;
    }

    fseek(file32, dos_header32.e_lfanew, SEEK_SET);
    NT_HEADER32 nt_header32;
    if (fread(&nt_header32, sizeof(NT_HEADER32), 1, file32) != 1) {
        fclose(file32);
        printf("Error reading the NT header.\n");
        return 1;
    }

    SECTION_HEADER section_header;
    vector<SECTION_HEADER> section_headers;
    for (int i = 0; i < nt_header32.FileHeader.NumberOfSections; i++) {
        if (fread(&section_header, sizeof(SECTION_HEADER), 1, file32) != 1) {
            fclose(file32);
            return 1;
        }
        section_headers.push_back(section_header);
    }

    printf("The executable is 32 bit");
    fclose(file32);

    return 0;
}

#pragma warning(disable : 4996)
int print_64_bit(const char* filePath) {
    FILE* file64 = fopen(filePath, "rb");
    if (!file64) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dos_header64;
    if (fread(&dos_header64, sizeof(DOS_HEADER), 1, file64) != 1) {
        fclose(file64);
        printf("Error reading DOS header\n");
        return 1;
    }

    fseek(file64, dos_header64.e_lfanew, SEEK_SET);
    NT_HEADER64 nt_header64;
    if (fread(&nt_header64, sizeof(NT_HEADER64), 1, file64) != 1) {
        fclose(file64);
        printf("Error reading the NT header.\n");
        return 1;
    }

    SECTION_HEADER section_header;
    vector<SECTION_HEADER> section_headers;
    for (int i = 0; i < nt_header64.FileHeader.NumberOfSections; i++) {
        if (fread(&section_header, sizeof(SECTION_HEADER), 1, file64) != 1) {
            fclose(file64);
            return 1;
        }
        section_headers.push_back(section_header);
    }

    DWORD import_table_rva = nt_header64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    DWORD import_table_va = 0;
    DWORD import_table_foa = 0;

    unsigned char name[8] = { '.', 'i', 'd', 'a', 't', 'a', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(name, s.Name, 8) == 0) {
            import_table_va = s.VirtualAddress;
            import_table_foa = s.PointerToRawData;
        }
    }

    DWORD import_directory_address = (import_table_rva - import_table_va) + import_table_foa;
    vector<IMPORT_DESCRIPTOR> import_descriptors;

    // Print all the entires in the import table and save them for later
    printf("-----Import Table-----\n");
    int count = 0;
    while (true) {
        IMPORT_DESCRIPTOR current_import;
        int offset = (count * sizeof(IMPORT_DESCRIPTOR)) + import_directory_address;
        fseek(file64, offset, SEEK_SET);
        fread(&current_import, sizeof(IMPORT_DESCRIPTOR), 1, file64);
        if (current_import.Name == 0x00000000 && current_import.FirstThunk == 0x00000000) {
            count -= 1;
            // _import_directory_size = _import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR);
            break;
        }
        printf("- Entry %d -\n", count + 1);
        printf("Characteristics: %#010x\n", current_import.Characteristics);
        printf("OriginalFirstThunk: %#010x\n", current_import.OriginalFirstThunk);
        printf("TimeDateStamp: %#010x\n", current_import.TimeDateStamp);
        printf("ForwarderChain: %#010x\n", current_import.ForwarderChain);
        printf("Name: %#010x\n", current_import.Name);
        printf("FirstThunk: %#010x\n\n", current_import.FirstThunk);

        count++;
        import_descriptors.push_back(current_import);
    }

    // print the all of the INT tables and the name table associated with each one
    DWORD INT_address = (import_descriptors[0].OriginalFirstThunk - import_table_va) + import_table_foa; // address of first INT table

    for (int i = 0; i < import_descriptors.size(); i++) {
		IMPORT_DESCRIPTOR current_import = import_descriptors[i];
		printf("-----INT Table %d-----\n", i + 1);
		int count = 0;
        vector<ULONGLONG> INT_entries;
        while (true) {
			int offset = (count * sizeof(ULONGLONG)) + INT_address;
			ULONGLONG current_INT;
			fseek(file64, offset, SEEK_SET);
			fread(&current_INT, sizeof(ULONGLONG), 1, file64);
            if (current_INT == 0x00000000) {
				count -= 1;
				break;
			}
			printf("Entry %d: %#010x\n", count+1,current_INT);
            INT_entries.push_back(current_INT);
			count++;
		}
		printf("\n");

		// print the name table associated with the INT table
		int name_table_address = (INT_entries[0] - import_table_va) + import_table_foa;
		printf("-----Name Table %d-----\n", i + 1);
		count = 0;
        while (true) {
			int offset = (count * sizeof(DWORD)) + name_table_address;
			DWORD current_name;
			fseek(file64, offset, SEEK_SET);
			fread(&current_name, sizeof(DWORD), 1, file64);
            if (current_name == 0x00000000) {
				count -= 1;
				break;
			}
			printf("Entry %d\n", count + 1);
			printf("\tName: %#010x\n", current_name);
			count++;
		}
		printf("\n");   

        for (int i = 0; i < INT_entries.size(); i++) {
            ULONGLONG INT = INT_entries[i];
            int MSB = 0; // TODO get most significant bit
            if (MSB == 1) {
                // ordinal number

            }
            else if (MSB == 0) {
                // RVA to name/hint struct
                
            }
        }
    
	}   


    printf("\n\nThe executable is 64 bit");
    fclose(file64);

    return 0;
}

#pragma warning(disable : 4996)
int print_tables(const char* filePath) {
    FILE* file = fopen(filePath, "rb");
    if (!file) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dosHeader;
    if (fread(&dosHeader, sizeof(DOS_HEADER), 1, file) != 1) {
        fclose(file);
        printf("Error reading DOS header\n");
        return 1;
    }

    fseek(file, dosHeader.e_lfanew, SEEK_SET);
    NT_HEADER32 ntHeader;
    if (fread(&ntHeader, sizeof(NT_HEADER32), 1, file) != 1) {
        fclose(file);
        printf("Error reading the NT header.\n");
        return 1;
    }

    if (ntHeader.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
        return print_64_bit(filePath);

    }
    else if (ntHeader.FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
        return print_32_bit(filePath);
    }
    else {
        printf("Error executable not 64 or 32 bit");
        return 1;
    }

    return 0;
}

int main(int argc, char* argv[]) {

    if (argc != 2) {
        printf("Incorrect arugments - please provide a file path to an executable\n");
        return 1;
    }

    const char* filePath = argv[1];

    return print_tables(filePath);
}
