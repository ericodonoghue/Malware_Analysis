#include <stdio.h>
#include <Windows.h>
#include <vector>
using namespace std;

typedef struct DOS_HEADER {             // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} __IMAGE_DOS_HEADER;

typedef struct DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} __IMAGE_DATA_DIRECTORY;

typedef struct FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} __IMAGE_FILE_HEADER;

typedef struct OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER64;

typedef struct OPTIONAL_HEADER32 {
    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;
    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER32;

typedef struct NT_HEADER64 {
    DWORD Signature;
    FILE_HEADER FileHeader;
    OPTIONAL_HEADER64 OptionalHeader;
} __IMAGE_NT_HEADERS64;

typedef struct NT_HEADER32 {
    DWORD Signature;
    FILE_HEADER FileHeader;
    OPTIONAL_HEADER32 OptionalHeader;
} __IMAGE_NT_HEADERS32;

typedef struct SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} __IMAGE_SECTION_HEADER;

typedef struct IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;
        DWORD   OriginalFirstThunk;
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;
    DWORD   ForwarderChain;
    DWORD   Name;
    DWORD   FirstThunk;
} __IMAGE_IMPORT_DESCRIPTOR;

typedef struct IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} __IMAGE_IMPORT_BY_NAME;

typedef struct BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;
    // Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} __IMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} __IMAGE_BOUND_FORWARDER_REF;

typedef struct BASE_RELOCATION {
    DWORD VirtualAddress;
    DWORD SizeOfBlock;
} __IMAGE_BASE_RELOCATION;

typedef struct EXPORT_DIRECTORY {
    DWORD   Characteristics;                         
    DWORD   TimeDateStamp;                       
    WORD    MajorVersion;                            
    WORD    MinorVersion;                             
    DWORD   Name;                         
    DWORD   Base;
    DWORD   NumberOfFunctions;              
    DWORD   NumberOfNames;                
    DWORD   AddressOfFunctions;                
    DWORD   AddressOfNames;                     
    DWORD   AddressOfNameOrdinals;       
} __IMAGE_EXPORT_DIRECTORY;



#pragma warning(disable : 4996)
int print_32_bit(const char* filePath) {
    FILE* file32 = fopen(filePath, "rb");
    if (!file32) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dos_header32;
    if (fread(&dos_header32, sizeof(DOS_HEADER), 1, file32) != 1) {
        fclose(file32);
        printf("Error reading DOS header\n");
        return 1;
    }

    fseek(file32, dos_header32.e_lfanew, SEEK_SET);
    NT_HEADER32 nt_header32;
    if (fread(&nt_header32, sizeof(NT_HEADER32), 1, file32) != 1) {
        fclose(file32);
        printf("Error reading the NT header.\n");
        return 1;
    }

    SECTION_HEADER section_header;
    vector<SECTION_HEADER> section_headers;
    for (int i = 0; i < nt_header32.FileHeader.NumberOfSections; i++) {
        if (fread(&section_header, sizeof(SECTION_HEADER), 1, file32) != 1) {
            fclose(file32);
            return 1;
        }
        section_headers.push_back(section_header);
    }

    DWORD import_table_rva = nt_header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    DWORD import_table_va = 0;
    DWORD import_table_foa = 0;

    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (s.VirtualAddress < import_table_rva && import_table_rva < s.VirtualAddress + s.Misc.VirtualSize) {
            import_table_va = s.VirtualAddress;
            import_table_foa = s.PointerToRawData;
            break;
        }
    }


    if (import_table_va == 0) {
		printf("Import table not found\n");
	}
    else {
        DWORD import_directory_address = (import_table_rva - import_table_va) + import_table_foa;
        vector<IMPORT_DESCRIPTOR> import_descriptors;

        // Print all the entires in the import table and save them for later
        printf("-----Import Table-----\n");
        int count = 0;
        while (true) {
            IMPORT_DESCRIPTOR current_import;
            int offset = (count * sizeof(IMPORT_DESCRIPTOR)) + import_directory_address;
            fseek(file32, offset, SEEK_SET);
            fread(&current_import, sizeof(IMPORT_DESCRIPTOR), 1, file32);
            if (current_import.Name == 0x0000 && current_import.FirstThunk == 0x0000) {
                break;
            }
            printf("- Entry %d -\n", count + 1);
            printf("Characteristics: %#06x\n", current_import.Characteristics);
            printf("OriginalFirstThunk: %#06x\n", current_import.OriginalFirstThunk);
            printf("TimeDateStamp: %#06x\n", current_import.TimeDateStamp);
            printf("ForwarderChain: %#06x\n", current_import.ForwarderChain);
            printf("Name: %#06x\n", current_import.Name);
            printf("FirstThunk: %#06x\n\n", current_import.FirstThunk);

            count++;
            import_descriptors.push_back(current_import);
        }

        // print the all of the INT tables and the name table associated with each one
        for (int i = 0; i < import_descriptors.size(); i++) {
            printf("-----INT Table %d-----\n", i + 1);
            DWORD INT_address = (import_descriptors[i].OriginalFirstThunk - import_table_va) + import_table_foa;
            int count = 0;
            vector<DWORD> INT_entries;
            while (true) {
                int offset = (count * sizeof(DWORD)) + INT_address;
                DWORD current_INT;
                fseek(file32, offset, SEEK_SET);
                fread(&current_INT, sizeof(DWORD), 1, file32);
                if (current_INT == 0x0000) {
                    break;
                }
                printf("Entry %d: %#06x\n", count + 1, current_INT);
                INT_entries.push_back(current_INT);
                count++;
            }
            printf("\n");

            // print the name table associated with the INT table
            printf("-----Name Table %d-----\n", i + 1);
            for (int j = 0; j < INT_entries.size(); j++) {
                DWORD INT = INT_entries[j];
                int MSB = INT >> 31;

                if (MSB == 0) {
                    // INT is a RVA to name/hint struct
                    // calculate address 
                    DWORD name_address = (INT - import_table_va) + import_table_foa;

                    IMPORT_BY_NAME current_name;
                    fseek(file32, name_address, SEEK_SET);
                    fread(&current_name, sizeof(IMPORT_BY_NAME), 1, file32);
                    printf("- Entry %d -\n", j + 1);
                    printf("Hint: %d\n", current_name.Hint);
                    printf("Name: ");
                    int c = 0;
                    while (true) {
                        int offset = (c * sizeof(CHAR)) + name_address + sizeof(WORD);
                        CHAR current_char;
                        fseek(file32, offset, SEEK_SET);
                        fread(&current_char, sizeof(CHAR), 1, file32);
                        if (current_char == 0x00) {
                            c -= 1;
                            break;
                        }
                        c++;
                        printf("%c", current_char);
                    }
                    printf("\n");
                }
            }
            printf("\n");
        }

        // print the all of the IAT tables
        for (int i = 0; i < import_descriptors.size(); i++) {
            printf("-----IAT Table %d-----\n", i + 1);
            DWORD IAT_address = (import_descriptors[i].FirstThunk - import_table_va) + import_table_foa;
            int count = 0;
            while (true) {
                int offset = (count * sizeof(DWORD)) + IAT_address;
                DWORD current_IAT;
                fseek(file32, offset, SEEK_SET);
                fread(&current_IAT, sizeof(DWORD), 1, file32);
                if (current_IAT == 0x0000) {
                    break;
                }
                printf("Entry %d: %#06x\n", count + 1, current_IAT);
                count++;
            }
            printf("\n");
        }
    }

    #pragma region print bound import table info

    DWORD bound_table_rva = nt_header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;

    if (bound_table_rva == 0) {
        printf("Bound import table not found\n");
    }
    else {
        DWORD bound_directory_address = bound_table_rva;
        printf("-----Bound Import Table-----\n");
        int bound_import_count = 0;
        int forwader_ref_count = 0;
        while (true) {
            BOUND_IMPORT_DESCRIPTOR current_bound;
            int offset = (bound_import_count * sizeof(BOUND_IMPORT_DESCRIPTOR)) + (forwader_ref_count * sizeof(BOUND_FORWARDER_REF)) + bound_directory_address;
            fseek(file32, offset, SEEK_SET);
            fread(&current_bound, sizeof(BOUND_IMPORT_DESCRIPTOR), 1, file32);
            if (current_bound.TimeDateStamp == 0x0000 && current_bound.OffsetModuleName == 0x00 && current_bound.NumberOfModuleForwarderRefs == 0x00) {
                break;
            }
            printf("- Entry %d -\n", bound_import_count + 1);
            printf("TimeDateStamp: %#010x\n", current_bound.TimeDateStamp);
            printf("OffsetModuleName: ");
            int c = 0;
            while (true) {
                int o = (c * sizeof(CHAR)) + (current_bound.OffsetModuleName + bound_directory_address);
                CHAR current_char;
                fseek(file32, o, SEEK_SET);
                fread(&current_char, sizeof(CHAR), 1, file32);
                if (current_char == 0x00) {
                    break;
                }
                c++;
                printf("%c", current_char);
            }
            printf("\n");
            printf("NumberOfModuleForwarderRefs: %#010x\n\n", current_bound.NumberOfModuleForwarderRefs);

            offset += sizeof(BOUND_IMPORT_DESCRIPTOR);
            for (int i = 0; i < current_bound.NumberOfModuleForwarderRefs; i++) {
                printf("-----Bound Forwarder Ref %d-----\n", i + 1);
                BOUND_FORWARDER_REF current_forwarder_ref;
                fseek(file32, offset, SEEK_SET);
                fread(&current_forwarder_ref, sizeof(BOUND_FORWARDER_REF), 1, file32);
                printf("TimeDateStamp: %#010x\n", current_forwarder_ref.TimeDateStamp);
                printf("OffsetModuleName: ");
                int c = 0;
                while (true) {
                    int o = (c * sizeof(CHAR)) + (current_forwarder_ref.OffsetModuleName + bound_directory_address);
                    CHAR current_char;
                    fseek(file32, o, SEEK_SET);
                    fread(&current_char, sizeof(CHAR), 1, file32);
                    if (current_char == 0x00) {
                        break;
                    }
                    c++;
                    printf("%c", current_char);
                }
                printf("\n");
                printf("Reserved: %#010x\n\n", current_forwarder_ref.Reserved);

                offset += sizeof(BOUND_FORWARDER_REF);
                forwader_ref_count++;
            }

            bound_import_count++;

        }
    }
    printf("\n");
    #pragma endregion

    DWORD reloc_table_rva = nt_header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    DWORD reloc_table_va = 0;
    DWORD reloc_table_foa = 0;

    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (s.VirtualAddress < reloc_table_rva && reloc_table_rva < s.VirtualAddress + s.Misc.VirtualSize) {
            reloc_table_va = s.VirtualAddress;
            reloc_table_foa = s.PointerToRawData;
            break;
        }
    }

    if (reloc_table_va == 0) {
        printf("Relocation table not found\n");
    }
    else {
        DWORD reloc_directory_address = (reloc_table_rva - reloc_table_va) + reloc_table_foa;
        vector<BASE_RELOCATION> reloc_descriptors;

        // Print all the entires in the reloc table and save them for later
        printf("-----Relocation Table-----\n");
        int count = 0;
        int reloc_table_offset = 0;
        while (true) {
            BASE_RELOCATION current_reloc;
            int offset = reloc_table_offset + reloc_directory_address;
            fseek(file32, offset, SEEK_SET);
            fread(&current_reloc, sizeof(BASE_RELOCATION), 1, file32);
            if (current_reloc.VirtualAddress == 0x0000 && current_reloc.SizeOfBlock == 0x0000) {
                break;
            }
            printf("- Entry %d -\n", count + 1);
            printf("VirtualAddress: %#010x\n", current_reloc.VirtualAddress);
            printf("SizeOfBlock: %#010x\n", current_reloc.SizeOfBlock);

            offset += sizeof(BASE_RELOCATION);
            int size = current_reloc.SizeOfBlock - sizeof(BASE_RELOCATION);
            void* buffer = malloc(size);
            fseek(file32, offset, SEEK_SET);
            fread(buffer, size, 1, file32);
            for (int i = 0; i < size; i += 2) {
                WORD current_word = *(WORD*)((char*)buffer + i);
                printf("%#010x\n", current_word);
            }

            free(buffer);
            count++;
            reloc_table_offset += current_reloc.SizeOfBlock;
            reloc_descriptors.push_back(current_reloc);
        }
    }
    printf("\n");

    DWORD export_table_rva = nt_header32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    DWORD export_table_va = 0;
    DWORD export_table_foa = 0;

    bool export_table_found = false;
    unsigned char e_name[8] = { '.', 'e', 'd', 'a', 't', 'a', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(e_name, s.Name, 8) == 0) {
            export_table_va = s.VirtualAddress;
            export_table_foa = s.PointerToRawData;
            export_table_found = true;
        }
    }

    if (!export_table_found) {
        for (int i = 0; i < section_headers.size(); i++) {
            SECTION_HEADER s = section_headers[i];
            if (s.VirtualAddress < export_table_rva && export_table_rva < s.VirtualAddress + s.Misc.VirtualSize) {
                export_table_va = s.VirtualAddress;
                export_table_foa = s.PointerToRawData;
                break;
            }
        }
    }

    if (export_table_va == 0) {
        printf("Export table not found\n");
    }
    else {
        DWORD export_directory_address = (export_table_rva - export_table_va) + export_table_foa;
        printf("-----Export Table-----\n");
        EXPORT_DIRECTORY export_dir;
        fseek(file32, export_directory_address, SEEK_SET);
        fread(&export_dir, sizeof(EXPORT_DIRECTORY), 1, file32);
        printf("Characteristics: %#010x\n", export_dir.Characteristics);
        printf("TimeDateStamp: %#010x\n", export_dir.TimeDateStamp);
        printf("MajorVersion: %#010x\n", export_dir.MajorVersion);
        printf("MinorVersion: %#010x\n", export_dir.MinorVersion);
        printf("Name: %#010x\n", export_dir.Name);
        printf("Base: %#010x\n", export_dir.Base);
        printf("NumberOfFunctions: %#010x\n", export_dir.NumberOfFunctions);
        printf("NumberOfNames: %#010x\n", export_dir.NumberOfNames);
        printf("AddressOfFunctions: %#010x\n", export_dir.AddressOfFunctions);
        printf("AddressOfNames: %#010x\n", export_dir.AddressOfNames);
        printf("AddressOfNameOrdinals: %#010x\n\n", export_dir.AddressOfNameOrdinals);


        // print function addresses table
        printf("-----Function Addresses Table-----\n");
        DWORD function_addresses_address = (export_dir.AddressOfFunctions - export_table_va) + export_table_foa;
        for (int i = 0; i < export_dir.NumberOfFunctions; i++) {
            DWORD current_function_address = (i * sizeof(DWORD)) + function_addresses_address;
            DWORD current_function;
            fseek(file32, current_function_address, SEEK_SET);
            fread(&current_function, sizeof(DWORD), 1, file32);
            printf("- Entry %d -\n", i + 1);
            printf("Function Address: %#010x\n", current_function);
        }
        printf("\n");

        // print name ordinals table
        printf("-----Name Ordinals Table-----\n");
        DWORD name_ordinals_address = (export_dir.AddressOfNameOrdinals - export_table_va) + export_table_foa;
        for (int i = 0; i < export_dir.NumberOfNames; i++) {
            DWORD current_name_ordinal_address = (i * sizeof(WORD)) + name_ordinals_address;
            WORD current_name_ordinal;
            fseek(file32, current_name_ordinal_address, SEEK_SET);
            fread(&current_name_ordinal, sizeof(WORD), 1, file32);
            printf("- Entry %d -\n", i + 1);
            printf("Name Ordinal: %d\n", current_name_ordinal);
        }
        printf("\n");

        // print the name table
        printf("-----Name Table-----\n");
        DWORD name_table_address = (export_dir.AddressOfNames - export_table_va) + export_table_foa;
        for (int i = 0; i < export_dir.NumberOfNames; i++) {
            DWORD current_name_address = (i * sizeof(DWORD)) + name_table_address;
            DWORD current_name;
            fseek(file32, current_name_address, SEEK_SET);
            fread(&current_name, sizeof(DWORD), 1, file32);
            printf("- Entry %d -\n", i + 1);
            printf("Name: ");
            int c = 0;
            while (true) {
                int offset = (c * sizeof(CHAR)) + (current_name - export_table_va) + export_table_foa;
                CHAR current_char;
                fseek(file32, offset, SEEK_SET);
                fread(&current_char, sizeof(CHAR), 1, file32);
                if (current_char == 0x00) {
                    break;
                }
                c++;
                printf("%c", current_char);
            }
            printf("\n");
        }

    }
    printf("\n");


    printf("The file is 32 bit");
    fclose(file32);

    return 0;
}

#pragma warning(disable : 4996)
int print_64_bit(const char* filePath) {

    #pragma region get header info

    FILE* file64 = fopen(filePath, "rb");
    if (!file64) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dos_header64;
    if (fread(&dos_header64, sizeof(DOS_HEADER), 1, file64) != 1) {
        fclose(file64);
        printf("Error reading DOS header\n");
        return 1;
    }

    fseek(file64, dos_header64.e_lfanew, SEEK_SET);
    NT_HEADER64 nt_header64;
    if (fread(&nt_header64, sizeof(NT_HEADER64), 1, file64) != 1) {
        fclose(file64);
        printf("Error reading the NT header.\n");
        return 1;
    }

    SECTION_HEADER section_header;
    vector<SECTION_HEADER> section_headers;
    for (int i = 0; i < nt_header64.FileHeader.NumberOfSections; i++) {
        if (fread(&section_header, sizeof(SECTION_HEADER), 1, file64) != 1) {
            fclose(file64);
            return 1;
        }
        section_headers.push_back(section_header);
    }

    #pragma endregion


    #pragma region print import table info

    DWORD import_table_rva = nt_header64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    DWORD import_table_va = 0;
    DWORD import_table_foa = 0;


    bool import_table_found = false;
    unsigned char i_name[8] = { '.', 'i', 'd', 'a', 't', 'a', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(i_name, s.Name, 8) == 0) {
            import_table_va = s.VirtualAddress;
            import_table_foa = s.PointerToRawData;
            import_table_found = true;
        }
    }
    if (!import_table_found) {
        for (int i = 0; i < section_headers.size(); i++) {
            SECTION_HEADER s = section_headers[i];
            if (s.VirtualAddress < import_table_rva && import_table_rva < s.VirtualAddress + s.Misc.VirtualSize) {
                import_table_va = s.VirtualAddress;
                import_table_foa = s.PointerToRawData;
                break;
            }
        }
    }
    if (import_table_va == 0) {
        printf("Import table not found\n");
    }
    else {
        DWORD import_directory_address = (import_table_rva - import_table_va) + import_table_foa;
        vector<IMPORT_DESCRIPTOR> import_descriptors;

        // Print all the entires in the import table and save them for later
        printf("-----Import Table-----\n");
        int count = 0;
        while (true) {
            IMPORT_DESCRIPTOR current_import;
            int offset = (count * sizeof(IMPORT_DESCRIPTOR)) + import_directory_address;
            fseek(file64, offset, SEEK_SET);
            fread(&current_import, sizeof(IMPORT_DESCRIPTOR), 1, file64);
            if (current_import.Name == 0x00000000 && current_import.FirstThunk == 0x00000000) {
                break;
            }
            printf("- Entry %d -\n", count + 1);
            printf("Characteristics: %#010x\n", current_import.Characteristics);
            printf("OriginalFirstThunk: %#010x\n", current_import.OriginalFirstThunk);
            printf("TimeDateStamp: %#010x\n", current_import.TimeDateStamp);
            printf("ForwarderChain: %#010x\n", current_import.ForwarderChain);
            printf("Name: %#010x\n", current_import.Name);
            printf("FirstThunk: %#010x\n\n", current_import.FirstThunk);

            count++;
            import_descriptors.push_back(current_import);
        }

        // print the all of the INT tables and the name table associated with each oneS
        for (int i = 0; i < import_descriptors.size(); i++) {
            printf("-----INT Table %d-----\n", i + 1);
            DWORD INT_address = (import_descriptors[i].OriginalFirstThunk - import_table_va) + import_table_foa;
            int count = 0;
            vector<ULONGLONG> INT_entries;
            while (true) {
                int offset = (count * sizeof(ULONGLONG)) + INT_address;
                ULONGLONG current_INT;
                fseek(file64, offset, SEEK_SET);
                fread(&current_INT, sizeof(ULONGLONG), 1, file64);
                if (current_INT == 0x00000000) {
                    break;
                }
                printf("Entry %d: %#010x\n", count + 1, current_INT);
                INT_entries.push_back(current_INT);
                count++;
            }
            printf("\n");

            // print the name table associated with the INT table
            printf("-----Name Table %d-----\n", i + 1);
            for (int j = 0; j < INT_entries.size(); j++) {
                // TODO get most significant bit of INT
                ULONGLONG INT = INT_entries[j];
                int MSB = INT >> 63;

                if (MSB == 0) {
                    // INT is a RVA to name/hint struct
                    // calculate address 
                    DWORD name_address = (INT - import_table_va) + import_table_foa;

                    IMPORT_BY_NAME current_name;
                    fseek(file64, name_address, SEEK_SET);
                    fread(&current_name, sizeof(IMPORT_BY_NAME), 1, file64);
                    printf("- Entry %d -\n", j + 1);
                    printf("Hint: %d\n", current_name.Hint);
                    printf("Name: ");
                    int c = 0;
                    while (true) {
                        int offset = (c * sizeof(CHAR)) + name_address + sizeof(WORD);
                        CHAR current_char;
                        fseek(file64, offset, SEEK_SET);
                        fread(&current_char, sizeof(CHAR), 1, file64);
                        if (current_char == 0x00) {
                            break;
                        }
                        c++;
                        printf("%c", current_char);
                    }
                    printf("\n");
                }
            }
            printf("\n");
        }

        // print the all of the IAT tables
        for (int i = 0; i < import_descriptors.size(); i++) {
            printf("-----IAT Table %d-----\n", i + 1);
            DWORD IAT_address = (import_descriptors[i].FirstThunk - import_table_va) + import_table_foa;
            int count = 0;
            while (true) {
                int offset = (count * sizeof(ULONGLONG)) + IAT_address;
                ULONGLONG current_IAT;
                fseek(file64, offset, SEEK_SET);
                fread(&current_IAT, sizeof(ULONGLONG), 1, file64);
                if (current_IAT == 0x00000000) {
                    break;
                }
                printf("Entry %d: %#010x\n", count + 1, current_IAT);
                count++;
            }
            printf("\n");
        }
    }

    #pragma endregion 

    #pragma region print bound import table info

    DWORD bound_table_rva = nt_header64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;

    if (bound_table_rva == 0) {
        printf("Bound import table not found\n");
    }
    else {
        DWORD bound_directory_address = bound_table_rva;
		printf("-----Bound Import Table-----\n");
        int bound_import_count = 0;
        int forwader_ref_count = 0;
        while (true) {
            BOUND_IMPORT_DESCRIPTOR current_bound;
            int offset = (bound_import_count * sizeof(BOUND_IMPORT_DESCRIPTOR)) + (forwader_ref_count * sizeof(BOUND_FORWARDER_REF)) + bound_directory_address;
            fseek(file64, offset, SEEK_SET);
            fread(&current_bound, sizeof(BOUND_IMPORT_DESCRIPTOR), 1, file64);
            if (current_bound.TimeDateStamp == 0x0000 && current_bound.OffsetModuleName == 0x00 && current_bound.NumberOfModuleForwarderRefs == 0x00) {
                break;
            }
            printf("- Entry %d -\n", bound_import_count + 1);
            printf("TimeDateStamp: %#010x\n", current_bound.TimeDateStamp);
            printf("OffsetModuleName: ");
            int c = 0;
            while (true) {
                int o = (c * sizeof(CHAR)) + (current_bound.OffsetModuleName + bound_directory_address);
                CHAR current_char;
                fseek(file64, o, SEEK_SET);
                fread(&current_char, sizeof(CHAR), 1, file64);
                if (current_char == 0x00) {
                    break;
                }
                c++;
                printf("%c", current_char);
            }
            printf("\n");
            printf("NumberOfModuleForwarderRefs: %#010x\n\n", current_bound.NumberOfModuleForwarderRefs);

            offset += sizeof(BOUND_IMPORT_DESCRIPTOR);
            for (int i = 0; i < current_bound.NumberOfModuleForwarderRefs; i++) {
                printf("-----Bound Forwarder Ref %d-----\n", i + 1);
                BOUND_FORWARDER_REF current_forwarder_ref;
                fseek(file64, offset, SEEK_SET);
                fread(&current_forwarder_ref, sizeof(BOUND_FORWARDER_REF), 1, file64);
                printf("TimeDateStamp: %#010x\n", current_forwarder_ref.TimeDateStamp);
                printf("OffsetModuleName: ");
                int c = 0;
                while (true) {
                    int o = (c * sizeof(CHAR)) + (current_forwarder_ref.OffsetModuleName + bound_directory_address);
                    CHAR current_char;
                    fseek(file64, o, SEEK_SET);
                    fread(&current_char, sizeof(CHAR), 1, file64);
                    if (current_char == 0x00) {
                        break;
                    }
                    c++;
                    printf("%c", current_char);
                }
                printf("\n");
                printf("Reserved: %#010x\n\n", current_forwarder_ref.Reserved);

                offset += sizeof(BOUND_FORWARDER_REF);
                forwader_ref_count++;
            }

            bound_import_count++;
            
        }
    }
    printf("\n");
    #pragma endregion


    #pragma region print relocation table info

    DWORD reloc_table_rva = nt_header64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    DWORD reloc_table_va = 0;
    DWORD reloc_table_foa = 0;

    bool reloc_table_found = false;
    unsigned char r_name[8] = { '.', 'r', 'e', 'l', 'o', 'c', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(r_name, s.Name, 8) == 0) {
            reloc_table_va = s.VirtualAddress;
            reloc_table_foa = s.PointerToRawData;
            reloc_table_found = true;
        }
    }

    if (!reloc_table_found) {
        for (int i = 0; i < section_headers.size(); i++) {
            SECTION_HEADER s = section_headers[i];
            if (s.VirtualAddress < reloc_table_rva && reloc_table_rva < s.VirtualAddress + s.Misc.VirtualSize) {
                reloc_table_va = s.VirtualAddress;
                reloc_table_foa = s.PointerToRawData;
                break;
            }
        }
    }

    if (reloc_table_va == 0) {
        printf("Relocation table not found\n");
    }
    else {
        DWORD reloc_directory_address = (reloc_table_rva - reloc_table_va) + reloc_table_foa;
        vector<BASE_RELOCATION> reloc_descriptors;

        // Print all the entires in the reloc table and save them for later
        printf("-----Relocation Table-----\n");
        int count = 0;
        int reloc_table_offset = 0;
        while (true) {
            BASE_RELOCATION current_reloc;
            int offset = reloc_table_offset + reloc_directory_address;
            fseek(file64, offset, SEEK_SET);
            fread(&current_reloc, sizeof(BASE_RELOCATION), 1, file64);
            if (current_reloc.VirtualAddress == 0x0000 && current_reloc.SizeOfBlock == 0x0000) {
                break;
            }
            printf("- Entry %d -\n", count + 1);
            printf("VirtualAddress: %#010x\n", current_reloc.VirtualAddress);
            printf("SizeOfBlock: %#010x\n", current_reloc.SizeOfBlock);

            offset += sizeof(BASE_RELOCATION);
            int size = current_reloc.SizeOfBlock - sizeof(BASE_RELOCATION);
            void* buffer = malloc(size);
            fseek(file64, offset, SEEK_SET);
            fread(buffer, size, 1, file64);
            for (int i = 0; i < size; i += 2) {
                WORD current_word = *(WORD*)((char*)buffer + i);
                printf("%#010x\n", current_word);
            }

            free(buffer);
            count++;
            reloc_table_offset += current_reloc.SizeOfBlock;
            reloc_descriptors.push_back(current_reloc);
            printf("\n");
        }
    }

    #pragma endregion

    
    #pragma region print export table info

    DWORD export_table_rva = nt_header64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    DWORD export_table_va = 0;
    DWORD export_table_foa = 0;

    bool export_table_found = false;
    unsigned char e_name[8] = { '.', 'e', 'd', 'a', 't', 'a', '\0', '\0' };
    for (int i = 0; i < section_headers.size(); i++) {
        SECTION_HEADER s = section_headers[i];
        if (memcmp(e_name, s.Name, 8) == 0) {
            export_table_va = s.VirtualAddress;
            export_table_foa = s.PointerToRawData;
            export_table_found = true;
        }
    }

    if (!export_table_found) {
        for (int i = 0; i < section_headers.size(); i++) {
			SECTION_HEADER s = section_headers[i];
            if (s.VirtualAddress < export_table_rva && export_table_rva < s.VirtualAddress + s.Misc.VirtualSize) {
				export_table_va = s.VirtualAddress;
				export_table_foa = s.PointerToRawData;
                break;
			}
		}
    }

    if (export_table_va == 0) {
        printf("Export table not found\n");
    }
    else {
        DWORD export_directory_address = (export_table_rva - export_table_va) + export_table_foa;
        printf("-----Export Table-----\n");
        EXPORT_DIRECTORY export_dir;
        fseek(file64, export_directory_address, SEEK_SET);
        fread(&export_dir, sizeof(EXPORT_DIRECTORY), 1, file64);
        printf("Characteristics: %#010x\n", export_dir.Characteristics);
        printf("TimeDateStamp: %#010x\n", export_dir.TimeDateStamp);
        printf("MajorVersion: %#010x\n", export_dir.MajorVersion);
        printf("MinorVersion: %#010x\n", export_dir.MinorVersion);
        printf("Name: %#010x\n", export_dir.Name);
        printf("Base: %#010x\n", export_dir.Base);
        printf("NumberOfFunctions: %#010x\n", export_dir.NumberOfFunctions);
        printf("NumberOfNames: %#010x\n", export_dir.NumberOfNames);
        printf("AddressOfFunctions: %#010x\n", export_dir.AddressOfFunctions);
        printf("AddressOfNames: %#010x\n", export_dir.AddressOfNames);
        printf("AddressOfNameOrdinals: %#010x\n\n", export_dir.AddressOfNameOrdinals);


        // print function addresses table
        printf("-----Function Addresses Table-----\n");
        DWORD function_addresses_address = (export_dir.AddressOfFunctions - export_table_va) + export_table_foa;
        for (int i = 0; i < export_dir.NumberOfFunctions; i++) {
			DWORD current_function_address = (i * sizeof(DWORD)) + function_addresses_address;
			DWORD current_function;
			fseek(file64, current_function_address, SEEK_SET);
			fread(&current_function, sizeof(DWORD), 1, file64);
			printf("- Entry %d -\n", i + 1);
			printf("Function Address: %#010x\n", current_function);
		}
        printf("\n");

        // print name ordinals table
        printf("-----Name Ordinals Table-----\n");
        DWORD name_ordinals_address = (export_dir.AddressOfNameOrdinals - export_table_va) + export_table_foa;
        for (int i = 0; i < export_dir.NumberOfNames; i++) {
            DWORD current_name_ordinal_address = (i * sizeof(WORD)) + name_ordinals_address;
            WORD current_name_ordinal;
            fseek(file64, current_name_ordinal_address, SEEK_SET);
            fread(&current_name_ordinal, sizeof(WORD), 1, file64);
            printf("- Entry %d -\n", i + 1);
            printf("Name Ordinal: %d\n", current_name_ordinal);
        }
        printf("\n");

        // print the name table
        printf("-----Name Table-----\n");
        DWORD name_table_address = (export_dir.AddressOfNames - export_table_va) + export_table_foa;
        for (int i = 0; i < export_dir.NumberOfNames; i++) {
			DWORD current_name_address = (i * sizeof(DWORD)) + name_table_address;
			DWORD current_name;
			fseek(file64, current_name_address, SEEK_SET);
			fread(&current_name, sizeof(DWORD), 1, file64);
			printf("- Entry %d -\n", i + 1);
            printf("Name Address: %#010x\n", current_name);
			printf("Name: ");
			int c = 0;
            while (true) {
				int offset = (c * sizeof(CHAR)) + (current_name - export_table_va) + export_table_foa;
				CHAR current_char;
				fseek(file64, offset, SEEK_SET);
				fread(&current_char, sizeof(CHAR), 1, file64);
                if (current_char == 0x0) {
					break;
				}
				c++;
				printf("%c", current_char);
			}
			printf("\n");
		}

    }
    printf("\n");

    #pragma endregion

    printf("\nThe file is 64 bit\n\n");
    fclose(file64);

    return 0;
}

#pragma warning(disable : 4996)
int print_tables(const char* filePath) {
    FILE* file = fopen(filePath, "rb");
    if (!file) {
        printf("Error opening file.\n");
        return 1;
    }

    DOS_HEADER dosHeader;
    if (fread(&dosHeader, sizeof(DOS_HEADER), 1, file) != 1) {
        fclose(file);
        printf("Error reading DOS header\n");
        return 1;
    }

    fseek(file, dosHeader.e_lfanew, SEEK_SET);
    NT_HEADER32 ntHeader;
    if (fread(&ntHeader, sizeof(NT_HEADER32), 1, file) != 1) {
        fclose(file);
        printf("Error reading the NT header.\n");
        return 1;
    }

    if (ntHeader.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
        return print_64_bit(filePath);

    }
    else if (ntHeader.FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
        return print_32_bit(filePath);
    }
    else {
        printf("Error executable not 64 or 32 bit");
        return 1;
    }

    return 0;
}

int main(int argc, char* argv[]) {

    if (argc != 2) {
        printf("Incorrect arugments - please provide a file path to an executable\n");
        return 1;
    }

    const char* filePath = argv[1];
    printf("File path: %s\n", filePath);

    return print_tables(filePath);
}
